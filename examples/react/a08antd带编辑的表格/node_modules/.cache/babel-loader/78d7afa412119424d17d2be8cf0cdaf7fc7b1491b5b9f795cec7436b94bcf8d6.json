{"ast":null,"code":"/**\n * Copyright (c) 2013-present, Facebook, Inc.\n * All rights reserved.\n *\n * This source code is licensed under the BSD-style license found in the\n * LICENSE file in the root directory of this source tree. An additional grant\n * of patent rights can be found in the PATENTS file in the same directory.\n *\n * @providesModule getTextContentFromFiles\n * @format\n * \n */\n\n'use strict';\n\nvar invariant = require('fbjs/lib/invariant');\nvar TEXT_CLIPPING_REGEX = /\\.textClipping$/;\nvar TEXT_TYPES = {\n  'text/plain': true,\n  'text/html': true,\n  'text/rtf': true\n};\n\n// Somewhat arbitrary upper bound on text size. Let's not lock up the browser.\nvar TEXT_SIZE_UPPER_BOUND = 5000;\n\n/**\n * Extract the text content from a file list.\n */\nfunction getTextContentFromFiles(files, callback) {\n  var readCount = 0;\n  var results = [];\n  files.forEach(function ( /*blob*/file) {\n    readFile(file, function ( /*string*/text) {\n      readCount++;\n      text && results.push(text.slice(0, TEXT_SIZE_UPPER_BOUND));\n      if (readCount == files.length) {\n        callback(results.join('\\r'));\n      }\n    });\n  });\n}\n\n/**\n * todo isaac: Do work to turn html/rtf into a content fragment.\n */\nfunction readFile(file, callback) {\n  if (!global.FileReader || file.type && !(file.type in TEXT_TYPES)) {\n    callback('');\n    return;\n  }\n  if (file.type === '') {\n    var contents = '';\n    // Special-case text clippings, which have an empty type but include\n    // `.textClipping` in the file name. `readAsText` results in an empty\n    // string for text clippings, so we force the file name to serve\n    // as the text value for the file.\n    if (TEXT_CLIPPING_REGEX.test(file.name)) {\n      contents = file.name.replace(TEXT_CLIPPING_REGEX, '');\n    }\n    callback(contents);\n    return;\n  }\n  var reader = new FileReader();\n  reader.onload = function () {\n    var result = reader.result;\n    !(typeof result === 'string') ? process.env.NODE_ENV !== 'production' ? invariant(false, 'We should be calling \"FileReader.readAsText\" which returns a string') : invariant(false) : void 0;\n    callback(result);\n  };\n  reader.onerror = function () {\n    callback('');\n  };\n  reader.readAsText(file);\n}\nmodule.exports = getTextContentFromFiles;","map":{"version":3,"names":["invariant","require","TEXT_CLIPPING_REGEX","TEXT_TYPES","TEXT_SIZE_UPPER_BOUND","getTextContentFromFiles","files","callback","readCount","results","forEach","file","readFile","text","push","slice","length","join","global","FileReader","type","contents","test","name","replace","reader","onload","result","process","env","NODE_ENV","onerror","readAsText","module","exports"],"sources":["/Users/zhangqiang/Documents/GitHub/frontEnd-all-knowledge/examples/react/a08antd带编辑的表格/node_modules/rc-editor-core/node_modules/draft-js/lib/getTextContentFromFiles.js"],"sourcesContent":["/**\n * Copyright (c) 2013-present, Facebook, Inc.\n * All rights reserved.\n *\n * This source code is licensed under the BSD-style license found in the\n * LICENSE file in the root directory of this source tree. An additional grant\n * of patent rights can be found in the PATENTS file in the same directory.\n *\n * @providesModule getTextContentFromFiles\n * @format\n * \n */\n\n'use strict';\n\nvar invariant = require('fbjs/lib/invariant');\n\nvar TEXT_CLIPPING_REGEX = /\\.textClipping$/;\n\nvar TEXT_TYPES = {\n  'text/plain': true,\n  'text/html': true,\n  'text/rtf': true\n};\n\n// Somewhat arbitrary upper bound on text size. Let's not lock up the browser.\nvar TEXT_SIZE_UPPER_BOUND = 5000;\n\n/**\n * Extract the text content from a file list.\n */\nfunction getTextContentFromFiles(files, callback) {\n  var readCount = 0;\n  var results = [];\n  files.forEach(function ( /*blob*/file) {\n    readFile(file, function ( /*string*/text) {\n      readCount++;\n      text && results.push(text.slice(0, TEXT_SIZE_UPPER_BOUND));\n      if (readCount == files.length) {\n        callback(results.join('\\r'));\n      }\n    });\n  });\n}\n\n/**\n * todo isaac: Do work to turn html/rtf into a content fragment.\n */\nfunction readFile(file, callback) {\n  if (!global.FileReader || file.type && !(file.type in TEXT_TYPES)) {\n    callback('');\n    return;\n  }\n\n  if (file.type === '') {\n    var contents = '';\n    // Special-case text clippings, which have an empty type but include\n    // `.textClipping` in the file name. `readAsText` results in an empty\n    // string for text clippings, so we force the file name to serve\n    // as the text value for the file.\n    if (TEXT_CLIPPING_REGEX.test(file.name)) {\n      contents = file.name.replace(TEXT_CLIPPING_REGEX, '');\n    }\n    callback(contents);\n    return;\n  }\n\n  var reader = new FileReader();\n  reader.onload = function () {\n    var result = reader.result;\n    !(typeof result === 'string') ? process.env.NODE_ENV !== 'production' ? invariant(false, 'We should be calling \"FileReader.readAsText\" which returns a string') : invariant(false) : void 0;\n    callback(result);\n  };\n  reader.onerror = function () {\n    callback('');\n  };\n  reader.readAsText(file);\n}\n\nmodule.exports = getTextContentFromFiles;"],"mappings":"AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,YAAY;;AAEZ,IAAIA,SAAS,GAAGC,OAAO,CAAC,oBAAoB,CAAC;AAE7C,IAAIC,mBAAmB,GAAG,iBAAiB;AAE3C,IAAIC,UAAU,GAAG;EACf,YAAY,EAAE,IAAI;EAClB,WAAW,EAAE,IAAI;EACjB,UAAU,EAAE;AACd,CAAC;;AAED;AACA,IAAIC,qBAAqB,GAAG,IAAI;;AAEhC;AACA;AACA;AACA,SAASC,uBAAuBA,CAACC,KAAK,EAAEC,QAAQ,EAAE;EAChD,IAAIC,SAAS,GAAG,CAAC;EACjB,IAAIC,OAAO,GAAG,EAAE;EAChBH,KAAK,CAACI,OAAO,CAAC,WAAW,QAAQC,IAAI,EAAE;IACrCC,QAAQ,CAACD,IAAI,EAAE,WAAW,UAAUE,IAAI,EAAE;MACxCL,SAAS,EAAE;MACXK,IAAI,IAAIJ,OAAO,CAACK,IAAI,CAACD,IAAI,CAACE,KAAK,CAAC,CAAC,EAAEX,qBAAqB,CAAC,CAAC;MAC1D,IAAII,SAAS,IAAIF,KAAK,CAACU,MAAM,EAAE;QAC7BT,QAAQ,CAACE,OAAO,CAACQ,IAAI,CAAC,IAAI,CAAC,CAAC;MAC9B;IACF,CAAC,CAAC;EACJ,CAAC,CAAC;AACJ;;AAEA;AACA;AACA;AACA,SAASL,QAAQA,CAACD,IAAI,EAAEJ,QAAQ,EAAE;EAChC,IAAI,CAACW,MAAM,CAACC,UAAU,IAAIR,IAAI,CAACS,IAAI,IAAI,EAAET,IAAI,CAACS,IAAI,IAAIjB,UAAU,CAAC,EAAE;IACjEI,QAAQ,CAAC,EAAE,CAAC;IACZ;EACF;EAEA,IAAII,IAAI,CAACS,IAAI,KAAK,EAAE,EAAE;IACpB,IAAIC,QAAQ,GAAG,EAAE;IACjB;IACA;IACA;IACA;IACA,IAAInB,mBAAmB,CAACoB,IAAI,CAACX,IAAI,CAACY,IAAI,CAAC,EAAE;MACvCF,QAAQ,GAAGV,IAAI,CAACY,IAAI,CAACC,OAAO,CAACtB,mBAAmB,EAAE,EAAE,CAAC;IACvD;IACAK,QAAQ,CAACc,QAAQ,CAAC;IAClB;EACF;EAEA,IAAII,MAAM,GAAG,IAAIN,UAAU,CAAC,CAAC;EAC7BM,MAAM,CAACC,MAAM,GAAG,YAAY;IAC1B,IAAIC,MAAM,GAAGF,MAAM,CAACE,MAAM;IAC1B,EAAE,OAAOA,MAAM,KAAK,QAAQ,CAAC,GAAGC,OAAO,CAACC,GAAG,CAACC,QAAQ,KAAK,YAAY,GAAG9B,SAAS,CAAC,KAAK,EAAE,qEAAqE,CAAC,GAAGA,SAAS,CAAC,KAAK,CAAC,GAAG,KAAK,CAAC;IAC3LO,QAAQ,CAACoB,MAAM,CAAC;EAClB,CAAC;EACDF,MAAM,CAACM,OAAO,GAAG,YAAY;IAC3BxB,QAAQ,CAAC,EAAE,CAAC;EACd,CAAC;EACDkB,MAAM,CAACO,UAAU,CAACrB,IAAI,CAAC;AACzB;AAEAsB,MAAM,CAACC,OAAO,GAAG7B,uBAAuB"},"metadata":{},"sourceType":"script","externalDependencies":[]}