{"ast":null,"code":"/**\n * Copyright (c) 2013-present, Facebook, Inc.\n * All rights reserved.\n *\n * This source code is licensed under the BSD-style license found in the\n * LICENSE file in the root directory of this source tree. An additional grant\n * of patent rights can be found in the PATENTS file in the same directory.\n *\n * @providesModule getDraftEditorSelectionWithNodes\n * @format\n * \n */\n\n'use strict';\n\nvar findAncestorOffsetKey = require('./findAncestorOffsetKey');\nvar getSelectionOffsetKeyForNode = require('./getSelectionOffsetKeyForNode');\nvar getUpdatedSelectionState = require('./getUpdatedSelectionState');\nvar invariant = require('fbjs/lib/invariant');\nvar nullthrows = require('fbjs/lib/nullthrows');\n\n/**\n * Convert the current selection range to an anchor/focus pair of offset keys\n * and values that can be interpreted by components.\n */\nfunction getDraftEditorSelectionWithNodes(editorState, root, anchorNode, anchorOffset, focusNode, focusOffset) {\n  var anchorIsTextNode = anchorNode.nodeType === Node.TEXT_NODE;\n  var focusIsTextNode = focusNode.nodeType === Node.TEXT_NODE;\n\n  // If the selection range lies only on text nodes, the task is simple.\n  // Find the nearest offset-aware elements and use the\n  // offset values supplied by the selection range.\n  if (anchorIsTextNode && focusIsTextNode) {\n    return {\n      selectionState: getUpdatedSelectionState(editorState, nullthrows(findAncestorOffsetKey(anchorNode)), anchorOffset, nullthrows(findAncestorOffsetKey(focusNode)), focusOffset),\n      needsRecovery: false\n    };\n  }\n  var anchorPoint = null;\n  var focusPoint = null;\n  var needsRecovery = true;\n\n  // An element is selected. Convert this selection range into leaf offset\n  // keys and offset values for consumption at the component level. This\n  // is common in Firefox, where select-all and triple click behavior leads\n  // to entire elements being selected.\n  //\n  // Note that we use the `needsRecovery` parameter in the callback here. This\n  // is because when certain elements are selected, the behavior for subsequent\n  // cursor movement (e.g. via arrow keys) is uncertain and may not match\n  // expectations at the component level. For example, if an entire <div> is\n  // selected and the user presses the right arrow, Firefox keeps the selection\n  // on the <div>. If we allow subsequent keypresses to insert characters\n  // natively, they will be inserted into a browser-created text node to the\n  // right of that <div>. This is obviously undesirable.\n  //\n  // With the `needsRecovery` flag, we inform the caller that it is responsible\n  // for manually setting the selection state on the rendered document to\n  // ensure proper selection state maintenance.\n\n  if (anchorIsTextNode) {\n    anchorPoint = {\n      key: nullthrows(findAncestorOffsetKey(anchorNode)),\n      offset: anchorOffset\n    };\n    focusPoint = getPointForNonTextNode(root, focusNode, focusOffset);\n  } else if (focusIsTextNode) {\n    focusPoint = {\n      key: nullthrows(findAncestorOffsetKey(focusNode)),\n      offset: focusOffset\n    };\n    anchorPoint = getPointForNonTextNode(root, anchorNode, anchorOffset);\n  } else {\n    anchorPoint = getPointForNonTextNode(root, anchorNode, anchorOffset);\n    focusPoint = getPointForNonTextNode(root, focusNode, focusOffset);\n\n    // If the selection is collapsed on an empty block, don't force recovery.\n    // This way, on arrow key selection changes, the browser can move the\n    // cursor from a non-zero offset on one block, through empty blocks,\n    // to a matching non-zero offset on other text blocks.\n    if (anchorNode === focusNode && anchorOffset === focusOffset) {\n      needsRecovery = !!anchorNode.firstChild && anchorNode.firstChild.nodeName !== 'BR';\n    }\n  }\n  return {\n    selectionState: getUpdatedSelectionState(editorState, anchorPoint.key, anchorPoint.offset, focusPoint.key, focusPoint.offset),\n    needsRecovery: needsRecovery\n  };\n}\n\n/**\n * Identify the first leaf descendant for the given node.\n */\nfunction getFirstLeaf(node) {\n  while (node.firstChild && (\n  // data-blocks has no offset\n  node.firstChild instanceof Element && node.firstChild.getAttribute('data-blocks') === 'true' || getSelectionOffsetKeyForNode(node.firstChild))) {\n    node = node.firstChild;\n  }\n  return node;\n}\n\n/**\n * Identify the last leaf descendant for the given node.\n */\nfunction getLastLeaf(node) {\n  while (node.lastChild && (\n  // data-blocks has no offset\n  node.lastChild instanceof Element && node.lastChild.getAttribute('data-blocks') === 'true' || getSelectionOffsetKeyForNode(node.lastChild))) {\n    node = node.lastChild;\n  }\n  return node;\n}\nfunction getPointForNonTextNode(editorRoot, startNode, childOffset) {\n  var node = startNode;\n  var offsetKey = findAncestorOffsetKey(node);\n  !(offsetKey != null || editorRoot && (editorRoot === node || editorRoot.firstChild === node)) ? process.env.NODE_ENV !== 'production' ? invariant(false, 'Unknown node in selection range.') : invariant(false) : void 0;\n\n  // If the editorRoot is the selection, step downward into the content\n  // wrapper.\n  if (editorRoot === node) {\n    node = node.firstChild;\n    !(node instanceof Element && node.getAttribute('data-contents') === 'true') ? process.env.NODE_ENV !== 'production' ? invariant(false, 'Invalid DraftEditorContents structure.') : invariant(false) : void 0;\n    if (childOffset > 0) {\n      childOffset = node.childNodes.length;\n    }\n  }\n\n  // If the child offset is zero and we have an offset key, we're done.\n  // If there's no offset key because the entire editor is selected,\n  // find the leftmost (\"first\") leaf in the tree and use that as the offset\n  // key.\n  if (childOffset === 0) {\n    var key = null;\n    if (offsetKey != null) {\n      key = offsetKey;\n    } else {\n      var firstLeaf = getFirstLeaf(node);\n      key = nullthrows(getSelectionOffsetKeyForNode(firstLeaf));\n    }\n    return {\n      key: key,\n      offset: 0\n    };\n  }\n  var nodeBeforeCursor = node.childNodes[childOffset - 1];\n  var leafKey = null;\n  var textLength = null;\n  if (!getSelectionOffsetKeyForNode(nodeBeforeCursor)) {\n    // Our target node may be a leaf or a text node, in which case we're\n    // already where we want to be and can just use the child's length as\n    // our offset.\n    leafKey = nullthrows(offsetKey);\n    textLength = getTextContentLength(nodeBeforeCursor);\n  } else {\n    // Otherwise, we'll look at the child to the left of the cursor and find\n    // the last leaf node in its subtree.\n    var lastLeaf = getLastLeaf(nodeBeforeCursor);\n    leafKey = nullthrows(getSelectionOffsetKeyForNode(lastLeaf));\n    textLength = getTextContentLength(lastLeaf);\n  }\n  return {\n    key: leafKey,\n    offset: textLength\n  };\n}\n\n/**\n * Return the length of a node's textContent, regarding single newline\n * characters as zero-length. This allows us to avoid problems with identifying\n * the correct selection offset for empty blocks in IE, in which we\n * render newlines instead of break tags.\n */\nfunction getTextContentLength(node) {\n  var textContent = node.textContent;\n  return textContent === '\\n' ? 0 : textContent.length;\n}\nmodule.exports = getDraftEditorSelectionWithNodes;","map":{"version":3,"names":["findAncestorOffsetKey","require","getSelectionOffsetKeyForNode","getUpdatedSelectionState","invariant","nullthrows","getDraftEditorSelectionWithNodes","editorState","root","anchorNode","anchorOffset","focusNode","focusOffset","anchorIsTextNode","nodeType","Node","TEXT_NODE","focusIsTextNode","selectionState","needsRecovery","anchorPoint","focusPoint","key","offset","getPointForNonTextNode","firstChild","nodeName","getFirstLeaf","node","Element","getAttribute","getLastLeaf","lastChild","editorRoot","startNode","childOffset","offsetKey","process","env","NODE_ENV","childNodes","length","firstLeaf","nodeBeforeCursor","leafKey","textLength","getTextContentLength","lastLeaf","textContent","module","exports"],"sources":["/Users/zhangqiang/Documents/GitHub/frontEnd-all-knowledge/examples/react/a08antd带编辑的表格/node_modules/rc-editor-mention/node_modules/draft-js/lib/getDraftEditorSelectionWithNodes.js"],"sourcesContent":["/**\n * Copyright (c) 2013-present, Facebook, Inc.\n * All rights reserved.\n *\n * This source code is licensed under the BSD-style license found in the\n * LICENSE file in the root directory of this source tree. An additional grant\n * of patent rights can be found in the PATENTS file in the same directory.\n *\n * @providesModule getDraftEditorSelectionWithNodes\n * @format\n * \n */\n\n'use strict';\n\nvar findAncestorOffsetKey = require('./findAncestorOffsetKey');\nvar getSelectionOffsetKeyForNode = require('./getSelectionOffsetKeyForNode');\nvar getUpdatedSelectionState = require('./getUpdatedSelectionState');\nvar invariant = require('fbjs/lib/invariant');\nvar nullthrows = require('fbjs/lib/nullthrows');\n\n/**\n * Convert the current selection range to an anchor/focus pair of offset keys\n * and values that can be interpreted by components.\n */\nfunction getDraftEditorSelectionWithNodes(editorState, root, anchorNode, anchorOffset, focusNode, focusOffset) {\n  var anchorIsTextNode = anchorNode.nodeType === Node.TEXT_NODE;\n  var focusIsTextNode = focusNode.nodeType === Node.TEXT_NODE;\n\n  // If the selection range lies only on text nodes, the task is simple.\n  // Find the nearest offset-aware elements and use the\n  // offset values supplied by the selection range.\n  if (anchorIsTextNode && focusIsTextNode) {\n    return {\n      selectionState: getUpdatedSelectionState(editorState, nullthrows(findAncestorOffsetKey(anchorNode)), anchorOffset, nullthrows(findAncestorOffsetKey(focusNode)), focusOffset),\n      needsRecovery: false\n    };\n  }\n\n  var anchorPoint = null;\n  var focusPoint = null;\n  var needsRecovery = true;\n\n  // An element is selected. Convert this selection range into leaf offset\n  // keys and offset values for consumption at the component level. This\n  // is common in Firefox, where select-all and triple click behavior leads\n  // to entire elements being selected.\n  //\n  // Note that we use the `needsRecovery` parameter in the callback here. This\n  // is because when certain elements are selected, the behavior for subsequent\n  // cursor movement (e.g. via arrow keys) is uncertain and may not match\n  // expectations at the component level. For example, if an entire <div> is\n  // selected and the user presses the right arrow, Firefox keeps the selection\n  // on the <div>. If we allow subsequent keypresses to insert characters\n  // natively, they will be inserted into a browser-created text node to the\n  // right of that <div>. This is obviously undesirable.\n  //\n  // With the `needsRecovery` flag, we inform the caller that it is responsible\n  // for manually setting the selection state on the rendered document to\n  // ensure proper selection state maintenance.\n\n  if (anchorIsTextNode) {\n    anchorPoint = {\n      key: nullthrows(findAncestorOffsetKey(anchorNode)),\n      offset: anchorOffset\n    };\n    focusPoint = getPointForNonTextNode(root, focusNode, focusOffset);\n  } else if (focusIsTextNode) {\n    focusPoint = {\n      key: nullthrows(findAncestorOffsetKey(focusNode)),\n      offset: focusOffset\n    };\n    anchorPoint = getPointForNonTextNode(root, anchorNode, anchorOffset);\n  } else {\n    anchorPoint = getPointForNonTextNode(root, anchorNode, anchorOffset);\n    focusPoint = getPointForNonTextNode(root, focusNode, focusOffset);\n\n    // If the selection is collapsed on an empty block, don't force recovery.\n    // This way, on arrow key selection changes, the browser can move the\n    // cursor from a non-zero offset on one block, through empty blocks,\n    // to a matching non-zero offset on other text blocks.\n    if (anchorNode === focusNode && anchorOffset === focusOffset) {\n      needsRecovery = !!anchorNode.firstChild && anchorNode.firstChild.nodeName !== 'BR';\n    }\n  }\n\n  return {\n    selectionState: getUpdatedSelectionState(editorState, anchorPoint.key, anchorPoint.offset, focusPoint.key, focusPoint.offset),\n    needsRecovery: needsRecovery\n  };\n}\n\n/**\n * Identify the first leaf descendant for the given node.\n */\nfunction getFirstLeaf(node) {\n  while (node.firstChild && (\n  // data-blocks has no offset\n  node.firstChild instanceof Element && node.firstChild.getAttribute('data-blocks') === 'true' || getSelectionOffsetKeyForNode(node.firstChild))) {\n    node = node.firstChild;\n  }\n  return node;\n}\n\n/**\n * Identify the last leaf descendant for the given node.\n */\nfunction getLastLeaf(node) {\n  while (node.lastChild && (\n  // data-blocks has no offset\n  node.lastChild instanceof Element && node.lastChild.getAttribute('data-blocks') === 'true' || getSelectionOffsetKeyForNode(node.lastChild))) {\n    node = node.lastChild;\n  }\n  return node;\n}\n\nfunction getPointForNonTextNode(editorRoot, startNode, childOffset) {\n  var node = startNode;\n  var offsetKey = findAncestorOffsetKey(node);\n\n  !(offsetKey != null || editorRoot && (editorRoot === node || editorRoot.firstChild === node)) ? process.env.NODE_ENV !== 'production' ? invariant(false, 'Unknown node in selection range.') : invariant(false) : void 0;\n\n  // If the editorRoot is the selection, step downward into the content\n  // wrapper.\n  if (editorRoot === node) {\n    node = node.firstChild;\n    !(node instanceof Element && node.getAttribute('data-contents') === 'true') ? process.env.NODE_ENV !== 'production' ? invariant(false, 'Invalid DraftEditorContents structure.') : invariant(false) : void 0;\n    if (childOffset > 0) {\n      childOffset = node.childNodes.length;\n    }\n  }\n\n  // If the child offset is zero and we have an offset key, we're done.\n  // If there's no offset key because the entire editor is selected,\n  // find the leftmost (\"first\") leaf in the tree and use that as the offset\n  // key.\n  if (childOffset === 0) {\n    var key = null;\n    if (offsetKey != null) {\n      key = offsetKey;\n    } else {\n      var firstLeaf = getFirstLeaf(node);\n      key = nullthrows(getSelectionOffsetKeyForNode(firstLeaf));\n    }\n    return { key: key, offset: 0 };\n  }\n\n  var nodeBeforeCursor = node.childNodes[childOffset - 1];\n  var leafKey = null;\n  var textLength = null;\n\n  if (!getSelectionOffsetKeyForNode(nodeBeforeCursor)) {\n    // Our target node may be a leaf or a text node, in which case we're\n    // already where we want to be and can just use the child's length as\n    // our offset.\n    leafKey = nullthrows(offsetKey);\n    textLength = getTextContentLength(nodeBeforeCursor);\n  } else {\n    // Otherwise, we'll look at the child to the left of the cursor and find\n    // the last leaf node in its subtree.\n    var lastLeaf = getLastLeaf(nodeBeforeCursor);\n    leafKey = nullthrows(getSelectionOffsetKeyForNode(lastLeaf));\n    textLength = getTextContentLength(lastLeaf);\n  }\n\n  return {\n    key: leafKey,\n    offset: textLength\n  };\n}\n\n/**\n * Return the length of a node's textContent, regarding single newline\n * characters as zero-length. This allows us to avoid problems with identifying\n * the correct selection offset for empty blocks in IE, in which we\n * render newlines instead of break tags.\n */\nfunction getTextContentLength(node) {\n  var textContent = node.textContent;\n  return textContent === '\\n' ? 0 : textContent.length;\n}\n\nmodule.exports = getDraftEditorSelectionWithNodes;"],"mappings":"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"},"metadata":{},"sourceType":"script","externalDependencies":[]}