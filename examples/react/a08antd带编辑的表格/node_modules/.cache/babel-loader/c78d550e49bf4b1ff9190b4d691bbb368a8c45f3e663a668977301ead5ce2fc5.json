{"ast":null,"code":"/**\n * Copyright (c) 2013-present, Facebook, Inc.\n * All rights reserved.\n *\n * This source code is licensed under the BSD-style license found in the\n * LICENSE file in the root directory of this source tree. An additional grant\n * of patent rights can be found in the PATENTS file in the same directory.\n *\n * @providesModule convertFromRawToDraftState\n * @format\n * \n */\n\n'use strict';\n\nvar _assign = require('object-assign');\nvar _extends = _assign || function (target) {\n  for (var i = 1; i < arguments.length; i++) {\n    var source = arguments[i];\n    for (var key in source) {\n      if (Object.prototype.hasOwnProperty.call(source, key)) {\n        target[key] = source[key];\n      }\n    }\n  }\n  return target;\n};\nvar ContentBlock = require('./ContentBlock');\nvar ContentBlockNode = require('./ContentBlockNode');\nvar ContentState = require('./ContentState');\nvar DraftEntity = require('./DraftEntity');\nvar DraftFeatureFlags = require('./DraftFeatureFlags');\nvar DraftTreeAdapter = require('./DraftTreeAdapter');\nvar Immutable = require('immutable');\nvar SelectionState = require('./SelectionState');\nvar createCharacterList = require('./createCharacterList');\nvar decodeEntityRanges = require('./decodeEntityRanges');\nvar decodeInlineStyleRanges = require('./decodeInlineStyleRanges');\nvar generateRandomKey = require('./generateRandomKey');\nvar invariant = require('fbjs/lib/invariant');\nvar experimentalTreeDataSupport = DraftFeatureFlags.draft_tree_data_support;\nvar List = Immutable.List,\n  Map = Immutable.Map,\n  OrderedMap = Immutable.OrderedMap;\nvar decodeBlockNodeConfig = function decodeBlockNodeConfig(block, entityMap) {\n  var key = block.key,\n    type = block.type,\n    data = block.data,\n    text = block.text,\n    depth = block.depth;\n  var blockNodeConfig = {\n    text: text,\n    depth: depth || 0,\n    type: type || 'unstyled',\n    key: key || generateRandomKey(),\n    data: Map(data),\n    characterList: decodeCharacterList(block, entityMap)\n  };\n  return blockNodeConfig;\n};\nvar decodeCharacterList = function decodeCharacterList(block, entityMap) {\n  var text = block.text,\n    rawEntityRanges = block.entityRanges,\n    rawInlineStyleRanges = block.inlineStyleRanges;\n  var entityRanges = rawEntityRanges || [];\n  var inlineStyleRanges = rawInlineStyleRanges || [];\n\n  // Translate entity range keys to the DraftEntity map.\n  return createCharacterList(decodeInlineStyleRanges(text, inlineStyleRanges), decodeEntityRanges(text, entityRanges.filter(function (range) {\n    return entityMap.hasOwnProperty(range.key);\n  }).map(function (range) {\n    return _extends({}, range, {\n      key: entityMap[range.key]\n    });\n  })));\n};\nvar addKeyIfMissing = function addKeyIfMissing(block) {\n  return _extends({}, block, {\n    key: block.key || generateRandomKey()\n  });\n};\n\n/**\n * Node stack is responsible to ensure we traverse the tree only once\n * in depth order, while also providing parent refs to inner nodes to\n * construct their links.\n */\nvar updateNodeStack = function updateNodeStack(stack, nodes, parentRef) {\n  var nodesWithParentRef = nodes.map(function (block) {\n    return _extends({}, block, {\n      parentRef: parentRef\n    });\n  });\n\n  // since we pop nodes from the stack we need to insert them in reverse\n  return stack.concat(nodesWithParentRef.reverse());\n};\n\n/**\n * This will build a tree draft content state by creating the node\n * reference links into a single tree walk. Each node has a link\n * reference to \"parent\", \"children\", \"nextSibling\" and \"prevSibling\"\n * blockMap will be created using depth ordering.\n */\nvar decodeContentBlockNodes = function decodeContentBlockNodes(blocks, entityMap) {\n  return blocks\n  // ensure children have valid keys to enable sibling links\n  .map(addKeyIfMissing).reduce(function (blockMap, block, index) {\n    !Array.isArray(block.children) ? process.env.NODE_ENV !== 'production' ? invariant(false, 'invalid RawDraftContentBlock can not be converted to ContentBlockNode') : invariant(false) : void 0;\n\n    // ensure children have valid keys to enable sibling links\n    var children = block.children.map(addKeyIfMissing);\n\n    // root level nodes\n    var contentBlockNode = new ContentBlockNode(_extends({}, decodeBlockNodeConfig(block, entityMap), {\n      prevSibling: index === 0 ? null : blocks[index - 1].key,\n      nextSibling: index === blocks.length - 1 ? null : blocks[index + 1].key,\n      children: List(children.map(function (child) {\n        return child.key;\n      }))\n    }));\n\n    // push root node to blockMap\n    blockMap = blockMap.set(contentBlockNode.getKey(), contentBlockNode);\n\n    // this stack is used to ensure we visit all nodes respecting depth ordering\n    var stack = updateNodeStack([], children, contentBlockNode);\n\n    // start computing children nodes\n    while (stack.length > 0) {\n      // we pop from the stack and start processing this node\n      var node = stack.pop();\n\n      // parentRef already points to a converted ContentBlockNode\n      var parentRef = node.parentRef;\n      var siblings = parentRef.getChildKeys();\n      var _index = siblings.indexOf(node.key);\n      var isValidBlock = Array.isArray(node.children);\n      if (!isValidBlock) {\n        !isValidBlock ? process.env.NODE_ENV !== 'production' ? invariant(false, 'invalid RawDraftContentBlock can not be converted to ContentBlockNode') : invariant(false) : void 0;\n        break;\n      }\n\n      // ensure children have valid keys to enable sibling links\n      var _children = node.children.map(addKeyIfMissing);\n      var _contentBlockNode = new ContentBlockNode(_extends({}, decodeBlockNodeConfig(node, entityMap), {\n        parent: parentRef.getKey(),\n        children: List(_children.map(function (child) {\n          return child.key;\n        })),\n        prevSibling: _index === 0 ? null : siblings.get(_index - 1),\n        nextSibling: _index === siblings.size - 1 ? null : siblings.get(_index + 1)\n      }));\n\n      // push node to blockMap\n      blockMap = blockMap.set(_contentBlockNode.getKey(), _contentBlockNode);\n\n      // this stack is used to ensure we visit all nodes respecting depth ordering\n      stack = updateNodeStack(stack, _children, _contentBlockNode);\n    }\n    return blockMap;\n  }, OrderedMap());\n};\nvar decodeContentBlocks = function decodeContentBlocks(blocks, entityMap) {\n  return OrderedMap(blocks.map(function (block) {\n    var contentBlock = new ContentBlock(decodeBlockNodeConfig(block, entityMap));\n    return [contentBlock.getKey(), contentBlock];\n  }));\n};\nvar decodeRawBlocks = function decodeRawBlocks(rawState, entityMap) {\n  var isTreeRawBlock = Array.isArray(rawState.blocks[0].children);\n  var rawBlocks = experimentalTreeDataSupport && !isTreeRawBlock ? DraftTreeAdapter.fromRawStateToRawTreeState(rawState).blocks : rawState.blocks;\n  if (!experimentalTreeDataSupport) {\n    return decodeContentBlocks(isTreeRawBlock ? DraftTreeAdapter.fromRawTreeStateToRawState(rawState).blocks : rawBlocks, entityMap);\n  }\n  return decodeContentBlockNodes(rawBlocks, entityMap);\n};\nvar decodeRawEntityMap = function decodeRawEntityMap(rawState) {\n  var rawEntityMap = rawState.entityMap;\n  var entityMap = {};\n\n  // TODO: Update this once we completely remove DraftEntity\n  Object.keys(rawEntityMap).forEach(function (rawEntityKey) {\n    var _rawEntityMap$rawEnti = rawEntityMap[rawEntityKey],\n      type = _rawEntityMap$rawEnti.type,\n      mutability = _rawEntityMap$rawEnti.mutability,\n      data = _rawEntityMap$rawEnti.data;\n\n    // get the key reference to created entity\n\n    entityMap[rawEntityKey] = DraftEntity.__create(type, mutability, data || {});\n  });\n  return entityMap;\n};\nvar convertFromRawToDraftState = function convertFromRawToDraftState(rawState) {\n  !Array.isArray(rawState.blocks) ? process.env.NODE_ENV !== 'production' ? invariant(false, 'invalid RawDraftContentState') : invariant(false) : void 0;\n\n  // decode entities\n  var entityMap = decodeRawEntityMap(rawState);\n\n  // decode blockMap\n  var blockMap = decodeRawBlocks(rawState, entityMap);\n\n  // create initial selection\n  var selectionState = blockMap.isEmpty() ? new SelectionState() : SelectionState.createEmpty(blockMap.first().getKey());\n  return new ContentState({\n    blockMap: blockMap,\n    entityMap: entityMap,\n    selectionBefore: selectionState,\n    selectionAfter: selectionState\n  });\n};\nmodule.exports = convertFromRawToDraftState;","map":{"version":3,"names":["_assign","require","_extends","target","i","arguments","length","source","key","Object","prototype","hasOwnProperty","call","ContentBlock","ContentBlockNode","ContentState","DraftEntity","DraftFeatureFlags","DraftTreeAdapter","Immutable","SelectionState","createCharacterList","decodeEntityRanges","decodeInlineStyleRanges","generateRandomKey","invariant","experimentalTreeDataSupport","draft_tree_data_support","List","Map","OrderedMap","decodeBlockNodeConfig","block","entityMap","type","data","text","depth","blockNodeConfig","characterList","decodeCharacterList","rawEntityRanges","entityRanges","rawInlineStyleRanges","inlineStyleRanges","filter","range","map","addKeyIfMissing","updateNodeStack","stack","nodes","parentRef","nodesWithParentRef","concat","reverse","decodeContentBlockNodes","blocks","reduce","blockMap","index","Array","isArray","children","process","env","NODE_ENV","contentBlockNode","prevSibling","nextSibling","child","set","getKey","node","pop","siblings","getChildKeys","_index","indexOf","isValidBlock","_children","_contentBlockNode","parent","get","size","decodeContentBlocks","contentBlock","decodeRawBlocks","rawState","isTreeRawBlock","rawBlocks","fromRawStateToRawTreeState","fromRawTreeStateToRawState","decodeRawEntityMap","rawEntityMap","keys","forEach","rawEntityKey","_rawEntityMap$rawEnti","mutability","__create","convertFromRawToDraftState","selectionState","isEmpty","createEmpty","first","selectionBefore","selectionAfter","module","exports"],"sources":["/Users/zhangqiang/Documents/GitHub/frontEnd-all-knowledge/examples/react/a08antd带编辑的表格/node_modules/rc-editor-core/node_modules/draft-js/lib/convertFromRawToDraftState.js"],"sourcesContent":["/**\n * Copyright (c) 2013-present, Facebook, Inc.\n * All rights reserved.\n *\n * This source code is licensed under the BSD-style license found in the\n * LICENSE file in the root directory of this source tree. An additional grant\n * of patent rights can be found in the PATENTS file in the same directory.\n *\n * @providesModule convertFromRawToDraftState\n * @format\n * \n */\n\n'use strict';\n\nvar _assign = require('object-assign');\n\nvar _extends = _assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; };\n\nvar ContentBlock = require('./ContentBlock');\nvar ContentBlockNode = require('./ContentBlockNode');\nvar ContentState = require('./ContentState');\nvar DraftEntity = require('./DraftEntity');\nvar DraftFeatureFlags = require('./DraftFeatureFlags');\nvar DraftTreeAdapter = require('./DraftTreeAdapter');\nvar Immutable = require('immutable');\nvar SelectionState = require('./SelectionState');\n\nvar createCharacterList = require('./createCharacterList');\nvar decodeEntityRanges = require('./decodeEntityRanges');\nvar decodeInlineStyleRanges = require('./decodeInlineStyleRanges');\nvar generateRandomKey = require('./generateRandomKey');\nvar invariant = require('fbjs/lib/invariant');\n\nvar experimentalTreeDataSupport = DraftFeatureFlags.draft_tree_data_support;\n\nvar List = Immutable.List,\n    Map = Immutable.Map,\n    OrderedMap = Immutable.OrderedMap;\n\n\nvar decodeBlockNodeConfig = function decodeBlockNodeConfig(block, entityMap) {\n  var key = block.key,\n      type = block.type,\n      data = block.data,\n      text = block.text,\n      depth = block.depth;\n\n\n  var blockNodeConfig = {\n    text: text,\n    depth: depth || 0,\n    type: type || 'unstyled',\n    key: key || generateRandomKey(),\n    data: Map(data),\n    characterList: decodeCharacterList(block, entityMap)\n  };\n\n  return blockNodeConfig;\n};\n\nvar decodeCharacterList = function decodeCharacterList(block, entityMap) {\n  var text = block.text,\n      rawEntityRanges = block.entityRanges,\n      rawInlineStyleRanges = block.inlineStyleRanges;\n\n\n  var entityRanges = rawEntityRanges || [];\n  var inlineStyleRanges = rawInlineStyleRanges || [];\n\n  // Translate entity range keys to the DraftEntity map.\n  return createCharacterList(decodeInlineStyleRanges(text, inlineStyleRanges), decodeEntityRanges(text, entityRanges.filter(function (range) {\n    return entityMap.hasOwnProperty(range.key);\n  }).map(function (range) {\n    return _extends({}, range, { key: entityMap[range.key] });\n  })));\n};\n\nvar addKeyIfMissing = function addKeyIfMissing(block) {\n  return _extends({}, block, {\n    key: block.key || generateRandomKey()\n  });\n};\n\n/**\n * Node stack is responsible to ensure we traverse the tree only once\n * in depth order, while also providing parent refs to inner nodes to\n * construct their links.\n */\nvar updateNodeStack = function updateNodeStack(stack, nodes, parentRef) {\n  var nodesWithParentRef = nodes.map(function (block) {\n    return _extends({}, block, {\n      parentRef: parentRef\n    });\n  });\n\n  // since we pop nodes from the stack we need to insert them in reverse\n  return stack.concat(nodesWithParentRef.reverse());\n};\n\n/**\n * This will build a tree draft content state by creating the node\n * reference links into a single tree walk. Each node has a link\n * reference to \"parent\", \"children\", \"nextSibling\" and \"prevSibling\"\n * blockMap will be created using depth ordering.\n */\nvar decodeContentBlockNodes = function decodeContentBlockNodes(blocks, entityMap) {\n  return blocks\n  // ensure children have valid keys to enable sibling links\n  .map(addKeyIfMissing).reduce(function (blockMap, block, index) {\n    !Array.isArray(block.children) ? process.env.NODE_ENV !== 'production' ? invariant(false, 'invalid RawDraftContentBlock can not be converted to ContentBlockNode') : invariant(false) : void 0;\n\n    // ensure children have valid keys to enable sibling links\n    var children = block.children.map(addKeyIfMissing);\n\n    // root level nodes\n    var contentBlockNode = new ContentBlockNode(_extends({}, decodeBlockNodeConfig(block, entityMap), {\n      prevSibling: index === 0 ? null : blocks[index - 1].key,\n      nextSibling: index === blocks.length - 1 ? null : blocks[index + 1].key,\n      children: List(children.map(function (child) {\n        return child.key;\n      }))\n    }));\n\n    // push root node to blockMap\n    blockMap = blockMap.set(contentBlockNode.getKey(), contentBlockNode);\n\n    // this stack is used to ensure we visit all nodes respecting depth ordering\n    var stack = updateNodeStack([], children, contentBlockNode);\n\n    // start computing children nodes\n    while (stack.length > 0) {\n      // we pop from the stack and start processing this node\n      var node = stack.pop();\n\n      // parentRef already points to a converted ContentBlockNode\n      var parentRef = node.parentRef;\n      var siblings = parentRef.getChildKeys();\n      var _index = siblings.indexOf(node.key);\n      var isValidBlock = Array.isArray(node.children);\n\n      if (!isValidBlock) {\n        !isValidBlock ? process.env.NODE_ENV !== 'production' ? invariant(false, 'invalid RawDraftContentBlock can not be converted to ContentBlockNode') : invariant(false) : void 0;\n        break;\n      }\n\n      // ensure children have valid keys to enable sibling links\n      var _children = node.children.map(addKeyIfMissing);\n\n      var _contentBlockNode = new ContentBlockNode(_extends({}, decodeBlockNodeConfig(node, entityMap), {\n        parent: parentRef.getKey(),\n        children: List(_children.map(function (child) {\n          return child.key;\n        })),\n        prevSibling: _index === 0 ? null : siblings.get(_index - 1),\n        nextSibling: _index === siblings.size - 1 ? null : siblings.get(_index + 1)\n      }));\n\n      // push node to blockMap\n      blockMap = blockMap.set(_contentBlockNode.getKey(), _contentBlockNode);\n\n      // this stack is used to ensure we visit all nodes respecting depth ordering\n      stack = updateNodeStack(stack, _children, _contentBlockNode);\n    }\n\n    return blockMap;\n  }, OrderedMap());\n};\n\nvar decodeContentBlocks = function decodeContentBlocks(blocks, entityMap) {\n  return OrderedMap(blocks.map(function (block) {\n    var contentBlock = new ContentBlock(decodeBlockNodeConfig(block, entityMap));\n    return [contentBlock.getKey(), contentBlock];\n  }));\n};\n\nvar decodeRawBlocks = function decodeRawBlocks(rawState, entityMap) {\n  var isTreeRawBlock = Array.isArray(rawState.blocks[0].children);\n  var rawBlocks = experimentalTreeDataSupport && !isTreeRawBlock ? DraftTreeAdapter.fromRawStateToRawTreeState(rawState).blocks : rawState.blocks;\n\n  if (!experimentalTreeDataSupport) {\n    return decodeContentBlocks(isTreeRawBlock ? DraftTreeAdapter.fromRawTreeStateToRawState(rawState).blocks : rawBlocks, entityMap);\n  }\n\n  return decodeContentBlockNodes(rawBlocks, entityMap);\n};\n\nvar decodeRawEntityMap = function decodeRawEntityMap(rawState) {\n  var rawEntityMap = rawState.entityMap;\n\n  var entityMap = {};\n\n  // TODO: Update this once we completely remove DraftEntity\n  Object.keys(rawEntityMap).forEach(function (rawEntityKey) {\n    var _rawEntityMap$rawEnti = rawEntityMap[rawEntityKey],\n        type = _rawEntityMap$rawEnti.type,\n        mutability = _rawEntityMap$rawEnti.mutability,\n        data = _rawEntityMap$rawEnti.data;\n\n    // get the key reference to created entity\n\n    entityMap[rawEntityKey] = DraftEntity.__create(type, mutability, data || {});\n  });\n\n  return entityMap;\n};\n\nvar convertFromRawToDraftState = function convertFromRawToDraftState(rawState) {\n  !Array.isArray(rawState.blocks) ? process.env.NODE_ENV !== 'production' ? invariant(false, 'invalid RawDraftContentState') : invariant(false) : void 0;\n\n  // decode entities\n  var entityMap = decodeRawEntityMap(rawState);\n\n  // decode blockMap\n  var blockMap = decodeRawBlocks(rawState, entityMap);\n\n  // create initial selection\n  var selectionState = blockMap.isEmpty() ? new SelectionState() : SelectionState.createEmpty(blockMap.first().getKey());\n\n  return new ContentState({\n    blockMap: blockMap,\n    entityMap: entityMap,\n    selectionBefore: selectionState,\n    selectionAfter: selectionState\n  });\n};\n\nmodule.exports = convertFromRawToDraftState;"],"mappings":"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"},"metadata":{},"sourceType":"script","externalDependencies":[]}