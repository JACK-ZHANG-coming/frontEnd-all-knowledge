{"ast":null,"code":"/**\n * Copyright (c) 2013-present, Facebook, Inc.\n * All rights reserved.\n *\n * This source code is licensed under the BSD-style license found in the\n * LICENSE file in the root directory of this source tree. An additional grant\n * of patent rights can be found in the PATENTS file in the same directory.\n *\n * @providesModule moveBlockInContentState\n * @format\n * \n */\n\n'use strict';\n\nvar ContentBlockNode = require('./ContentBlockNode');\nvar Immutable = require('immutable');\nvar getNextDelimiterBlockKey = require('./getNextDelimiterBlockKey');\nvar invariant = require('fbjs/lib/invariant');\nvar OrderedMap = Immutable.OrderedMap,\n  List = Immutable.List;\nvar transformBlock = function transformBlock(key, blockMap, func) {\n  if (!key) {\n    return;\n  }\n  var block = blockMap.get(key);\n  if (!block) {\n    return;\n  }\n  blockMap.set(key, func(block));\n};\nvar updateBlockMapLinks = function updateBlockMapLinks(blockMap, originalBlockToBeMoved, originalTargetBlock, insertionMode, isExperimentalTreeBlock) {\n  if (!isExperimentalTreeBlock) {\n    return blockMap;\n  }\n  // possible values of 'insertionMode' are: 'after', 'before'\n  var isInsertedAfterTarget = insertionMode === 'after';\n  var originalBlockKey = originalBlockToBeMoved.getKey();\n  var originalTargetKey = originalTargetBlock.getKey();\n  var originalParentKey = originalBlockToBeMoved.getParentKey();\n  var originalNextSiblingKey = originalBlockToBeMoved.getNextSiblingKey();\n  var originalPrevSiblingKey = originalBlockToBeMoved.getPrevSiblingKey();\n  var newParentKey = originalTargetBlock.getParentKey();\n  var newNextSiblingKey = isInsertedAfterTarget ? originalTargetBlock.getNextSiblingKey() : originalTargetKey;\n  var newPrevSiblingKey = isInsertedAfterTarget ? originalTargetKey : originalTargetBlock.getPrevSiblingKey();\n  return blockMap.withMutations(function (blocks) {\n    // update old parent\n    transformBlock(originalParentKey, blocks, function (block) {\n      var parentChildrenList = block.getChildKeys();\n      return block.merge({\n        children: parentChildrenList['delete'](parentChildrenList.indexOf(originalBlockKey))\n      });\n    });\n\n    // update old prev\n    transformBlock(originalPrevSiblingKey, blocks, function (block) {\n      return block.merge({\n        nextSibling: originalNextSiblingKey\n      });\n    });\n\n    // update old next\n    transformBlock(originalNextSiblingKey, blocks, function (block) {\n      return block.merge({\n        prevSibling: originalPrevSiblingKey\n      });\n    });\n\n    // update new next\n    transformBlock(newNextSiblingKey, blocks, function (block) {\n      return block.merge({\n        prevSibling: originalBlockKey\n      });\n    });\n\n    // update new prev\n    transformBlock(newPrevSiblingKey, blocks, function (block) {\n      return block.merge({\n        nextSibling: originalBlockKey\n      });\n    });\n\n    // update new parent\n    transformBlock(newParentKey, blocks, function (block) {\n      var newParentChildrenList = block.getChildKeys();\n      var targetBlockIndex = newParentChildrenList.indexOf(originalTargetKey);\n      var insertionIndex = isInsertedAfterTarget ? targetBlockIndex + 1 : targetBlockIndex !== 0 ? targetBlockIndex - 1 : 0;\n      var newChildrenArray = newParentChildrenList.toArray();\n      newChildrenArray.splice(insertionIndex, 0, originalBlockKey);\n      return block.merge({\n        children: List(newChildrenArray)\n      });\n    });\n\n    // update block\n    transformBlock(originalBlockKey, blocks, function (block) {\n      return block.merge({\n        nextSibling: newNextSiblingKey,\n        prevSibling: newPrevSiblingKey,\n        parent: newParentKey\n      });\n    });\n  });\n};\nvar moveBlockInContentState = function moveBlockInContentState(contentState, blockToBeMoved, targetBlock, insertionMode) {\n  !(insertionMode !== 'replace') ? process.env.NODE_ENV !== 'production' ? invariant(false, 'Replacing blocks is not supported.') : invariant(false) : void 0;\n  var targetKey = targetBlock.getKey();\n  var blockKey = blockToBeMoved.getKey();\n  !(blockKey !== targetKey) ? process.env.NODE_ENV !== 'production' ? invariant(false, 'Block cannot be moved next to itself.') : invariant(false) : void 0;\n  var blockMap = contentState.getBlockMap();\n  var isExperimentalTreeBlock = blockToBeMoved instanceof ContentBlockNode;\n  var blocksToBeMoved = [blockToBeMoved];\n  var blockMapWithoutBlocksToBeMoved = blockMap['delete'](blockKey);\n  if (isExperimentalTreeBlock) {\n    blocksToBeMoved = [];\n    blockMapWithoutBlocksToBeMoved = blockMap.withMutations(function (blocks) {\n      var nextSiblingKey = blockToBeMoved.getNextSiblingKey();\n      var nextDelimiterBlockKey = getNextDelimiterBlockKey(blockToBeMoved, blocks);\n      blocks.toSeq().skipUntil(function (block) {\n        return block.getKey() === blockKey;\n      }).takeWhile(function (block) {\n        var key = block.getKey();\n        var isBlockToBeMoved = key === blockKey;\n        var hasNextSiblingAndIsNotNextSibling = nextSiblingKey && key !== nextSiblingKey;\n        var doesNotHaveNextSiblingAndIsNotDelimiter = !nextSiblingKey && block.getParentKey() && (!nextDelimiterBlockKey || key !== nextDelimiterBlockKey);\n        return !!(isBlockToBeMoved || hasNextSiblingAndIsNotNextSibling || doesNotHaveNextSiblingAndIsNotDelimiter);\n      }).forEach(function (block) {\n        blocksToBeMoved.push(block);\n        blocks['delete'](block.getKey());\n      });\n    });\n  }\n  var blocksBefore = blockMapWithoutBlocksToBeMoved.toSeq().takeUntil(function (v) {\n    return v === targetBlock;\n  });\n  var blocksAfter = blockMapWithoutBlocksToBeMoved.toSeq().skipUntil(function (v) {\n    return v === targetBlock;\n  }).skip(1);\n  var slicedBlocks = blocksToBeMoved.map(function (block) {\n    return [block.getKey(), block];\n  });\n  var newBlocks = OrderedMap();\n  if (insertionMode === 'before') {\n    var blockBefore = contentState.getBlockBefore(targetKey);\n    !(!blockBefore || blockBefore.getKey() !== blockToBeMoved.getKey()) ? process.env.NODE_ENV !== 'production' ? invariant(false, 'Block cannot be moved next to itself.') : invariant(false) : void 0;\n    newBlocks = blocksBefore.concat([].concat(slicedBlocks, [[targetKey, targetBlock]]), blocksAfter).toOrderedMap();\n  } else if (insertionMode === 'after') {\n    var blockAfter = contentState.getBlockAfter(targetKey);\n    !(!blockAfter || blockAfter.getKey() !== blockKey) ? process.env.NODE_ENV !== 'production' ? invariant(false, 'Block cannot be moved next to itself.') : invariant(false) : void 0;\n    newBlocks = blocksBefore.concat([[targetKey, targetBlock]].concat(slicedBlocks), blocksAfter).toOrderedMap();\n  }\n  return contentState.merge({\n    blockMap: updateBlockMapLinks(newBlocks, blockToBeMoved, targetBlock, insertionMode, isExperimentalTreeBlock),\n    selectionBefore: contentState.getSelectionAfter(),\n    selectionAfter: contentState.getSelectionAfter().merge({\n      anchorKey: blockKey,\n      focusKey: blockKey\n    })\n  });\n};\nmodule.exports = moveBlockInContentState;","map":{"version":3,"names":["ContentBlockNode","require","Immutable","getNextDelimiterBlockKey","invariant","OrderedMap","List","transformBlock","key","blockMap","func","block","get","set","updateBlockMapLinks","originalBlockToBeMoved","originalTargetBlock","insertionMode","isExperimentalTreeBlock","isInsertedAfterTarget","originalBlockKey","getKey","originalTargetKey","originalParentKey","getParentKey","originalNextSiblingKey","getNextSiblingKey","originalPrevSiblingKey","getPrevSiblingKey","newParentKey","newNextSiblingKey","newPrevSiblingKey","withMutations","blocks","parentChildrenList","getChildKeys","merge","children","indexOf","nextSibling","prevSibling","newParentChildrenList","targetBlockIndex","insertionIndex","newChildrenArray","toArray","splice","parent","moveBlockInContentState","contentState","blockToBeMoved","targetBlock","process","env","NODE_ENV","targetKey","blockKey","getBlockMap","blocksToBeMoved","blockMapWithoutBlocksToBeMoved","nextSiblingKey","nextDelimiterBlockKey","toSeq","skipUntil","takeWhile","isBlockToBeMoved","hasNextSiblingAndIsNotNextSibling","doesNotHaveNextSiblingAndIsNotDelimiter","forEach","push","blocksBefore","takeUntil","v","blocksAfter","skip","slicedBlocks","map","newBlocks","blockBefore","getBlockBefore","concat","toOrderedMap","blockAfter","getBlockAfter","selectionBefore","getSelectionAfter","selectionAfter","anchorKey","focusKey","module","exports"],"sources":["/Users/zhangqiang/Documents/GitHub/frontEnd-all-knowledge/examples/react/a08antd带编辑的表格/node_modules/rc-editor-mention/node_modules/draft-js/lib/moveBlockInContentState.js"],"sourcesContent":["/**\n * Copyright (c) 2013-present, Facebook, Inc.\n * All rights reserved.\n *\n * This source code is licensed under the BSD-style license found in the\n * LICENSE file in the root directory of this source tree. An additional grant\n * of patent rights can be found in the PATENTS file in the same directory.\n *\n * @providesModule moveBlockInContentState\n * @format\n * \n */\n\n'use strict';\n\nvar ContentBlockNode = require('./ContentBlockNode');\nvar Immutable = require('immutable');\n\nvar getNextDelimiterBlockKey = require('./getNextDelimiterBlockKey');\nvar invariant = require('fbjs/lib/invariant');\n\nvar OrderedMap = Immutable.OrderedMap,\n    List = Immutable.List;\n\n\nvar transformBlock = function transformBlock(key, blockMap, func) {\n  if (!key) {\n    return;\n  }\n\n  var block = blockMap.get(key);\n\n  if (!block) {\n    return;\n  }\n\n  blockMap.set(key, func(block));\n};\n\nvar updateBlockMapLinks = function updateBlockMapLinks(blockMap, originalBlockToBeMoved, originalTargetBlock, insertionMode, isExperimentalTreeBlock) {\n  if (!isExperimentalTreeBlock) {\n    return blockMap;\n  }\n  // possible values of 'insertionMode' are: 'after', 'before'\n  var isInsertedAfterTarget = insertionMode === 'after';\n\n  var originalBlockKey = originalBlockToBeMoved.getKey();\n  var originalTargetKey = originalTargetBlock.getKey();\n  var originalParentKey = originalBlockToBeMoved.getParentKey();\n  var originalNextSiblingKey = originalBlockToBeMoved.getNextSiblingKey();\n  var originalPrevSiblingKey = originalBlockToBeMoved.getPrevSiblingKey();\n  var newParentKey = originalTargetBlock.getParentKey();\n  var newNextSiblingKey = isInsertedAfterTarget ? originalTargetBlock.getNextSiblingKey() : originalTargetKey;\n  var newPrevSiblingKey = isInsertedAfterTarget ? originalTargetKey : originalTargetBlock.getPrevSiblingKey();\n\n  return blockMap.withMutations(function (blocks) {\n    // update old parent\n    transformBlock(originalParentKey, blocks, function (block) {\n      var parentChildrenList = block.getChildKeys();\n      return block.merge({\n        children: parentChildrenList['delete'](parentChildrenList.indexOf(originalBlockKey))\n      });\n    });\n\n    // update old prev\n    transformBlock(originalPrevSiblingKey, blocks, function (block) {\n      return block.merge({\n        nextSibling: originalNextSiblingKey\n      });\n    });\n\n    // update old next\n    transformBlock(originalNextSiblingKey, blocks, function (block) {\n      return block.merge({\n        prevSibling: originalPrevSiblingKey\n      });\n    });\n\n    // update new next\n    transformBlock(newNextSiblingKey, blocks, function (block) {\n      return block.merge({\n        prevSibling: originalBlockKey\n      });\n    });\n\n    // update new prev\n    transformBlock(newPrevSiblingKey, blocks, function (block) {\n      return block.merge({\n        nextSibling: originalBlockKey\n      });\n    });\n\n    // update new parent\n    transformBlock(newParentKey, blocks, function (block) {\n      var newParentChildrenList = block.getChildKeys();\n      var targetBlockIndex = newParentChildrenList.indexOf(originalTargetKey);\n\n      var insertionIndex = isInsertedAfterTarget ? targetBlockIndex + 1 : targetBlockIndex !== 0 ? targetBlockIndex - 1 : 0;\n\n      var newChildrenArray = newParentChildrenList.toArray();\n      newChildrenArray.splice(insertionIndex, 0, originalBlockKey);\n\n      return block.merge({\n        children: List(newChildrenArray)\n      });\n    });\n\n    // update block\n    transformBlock(originalBlockKey, blocks, function (block) {\n      return block.merge({\n        nextSibling: newNextSiblingKey,\n        prevSibling: newPrevSiblingKey,\n        parent: newParentKey\n      });\n    });\n  });\n};\n\nvar moveBlockInContentState = function moveBlockInContentState(contentState, blockToBeMoved, targetBlock, insertionMode) {\n  !(insertionMode !== 'replace') ? process.env.NODE_ENV !== 'production' ? invariant(false, 'Replacing blocks is not supported.') : invariant(false) : void 0;\n\n  var targetKey = targetBlock.getKey();\n  var blockKey = blockToBeMoved.getKey();\n\n  !(blockKey !== targetKey) ? process.env.NODE_ENV !== 'production' ? invariant(false, 'Block cannot be moved next to itself.') : invariant(false) : void 0;\n\n  var blockMap = contentState.getBlockMap();\n  var isExperimentalTreeBlock = blockToBeMoved instanceof ContentBlockNode;\n\n  var blocksToBeMoved = [blockToBeMoved];\n  var blockMapWithoutBlocksToBeMoved = blockMap['delete'](blockKey);\n\n  if (isExperimentalTreeBlock) {\n    blocksToBeMoved = [];\n    blockMapWithoutBlocksToBeMoved = blockMap.withMutations(function (blocks) {\n      var nextSiblingKey = blockToBeMoved.getNextSiblingKey();\n      var nextDelimiterBlockKey = getNextDelimiterBlockKey(blockToBeMoved, blocks);\n\n      blocks.toSeq().skipUntil(function (block) {\n        return block.getKey() === blockKey;\n      }).takeWhile(function (block) {\n        var key = block.getKey();\n        var isBlockToBeMoved = key === blockKey;\n        var hasNextSiblingAndIsNotNextSibling = nextSiblingKey && key !== nextSiblingKey;\n        var doesNotHaveNextSiblingAndIsNotDelimiter = !nextSiblingKey && block.getParentKey() && (!nextDelimiterBlockKey || key !== nextDelimiterBlockKey);\n\n        return !!(isBlockToBeMoved || hasNextSiblingAndIsNotNextSibling || doesNotHaveNextSiblingAndIsNotDelimiter);\n      }).forEach(function (block) {\n        blocksToBeMoved.push(block);\n        blocks['delete'](block.getKey());\n      });\n    });\n  }\n\n  var blocksBefore = blockMapWithoutBlocksToBeMoved.toSeq().takeUntil(function (v) {\n    return v === targetBlock;\n  });\n\n  var blocksAfter = blockMapWithoutBlocksToBeMoved.toSeq().skipUntil(function (v) {\n    return v === targetBlock;\n  }).skip(1);\n\n  var slicedBlocks = blocksToBeMoved.map(function (block) {\n    return [block.getKey(), block];\n  });\n\n  var newBlocks = OrderedMap();\n\n  if (insertionMode === 'before') {\n    var blockBefore = contentState.getBlockBefore(targetKey);\n\n    !(!blockBefore || blockBefore.getKey() !== blockToBeMoved.getKey()) ? process.env.NODE_ENV !== 'production' ? invariant(false, 'Block cannot be moved next to itself.') : invariant(false) : void 0;\n\n    newBlocks = blocksBefore.concat([].concat(slicedBlocks, [[targetKey, targetBlock]]), blocksAfter).toOrderedMap();\n  } else if (insertionMode === 'after') {\n    var blockAfter = contentState.getBlockAfter(targetKey);\n\n    !(!blockAfter || blockAfter.getKey() !== blockKey) ? process.env.NODE_ENV !== 'production' ? invariant(false, 'Block cannot be moved next to itself.') : invariant(false) : void 0;\n\n    newBlocks = blocksBefore.concat([[targetKey, targetBlock]].concat(slicedBlocks), blocksAfter).toOrderedMap();\n  }\n\n  return contentState.merge({\n    blockMap: updateBlockMapLinks(newBlocks, blockToBeMoved, targetBlock, insertionMode, isExperimentalTreeBlock),\n    selectionBefore: contentState.getSelectionAfter(),\n    selectionAfter: contentState.getSelectionAfter().merge({\n      anchorKey: blockKey,\n      focusKey: blockKey\n    })\n  });\n};\n\nmodule.exports = moveBlockInContentState;"],"mappings":"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"},"metadata":{},"sourceType":"script","externalDependencies":[]}