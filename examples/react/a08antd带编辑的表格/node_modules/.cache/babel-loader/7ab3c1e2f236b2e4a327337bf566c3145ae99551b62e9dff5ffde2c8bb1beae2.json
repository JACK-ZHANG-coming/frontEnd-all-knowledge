{"ast":null,"code":"/**\n * Copyright (c) 2013-present, Facebook, Inc.\n * All rights reserved.\n *\n * This source code is licensed under the BSD-style license found in the\n * LICENSE file in the root directory of this source tree. An additional grant\n * of patent rights can be found in the PATENTS file in the same directory.\n *\n * @providesModule randomizeBlockMapKeys\n * @format\n * \n */\n\n'use strict';\n\nvar ContentBlockNode = require('./ContentBlockNode');\nvar Immutable = require('immutable');\nvar generateRandomKey = require('./generateRandomKey');\nvar OrderedMap = Immutable.OrderedMap;\nvar randomizeContentBlockNodeKeys = function randomizeContentBlockNodeKeys(blockMap) {\n  var newKeysRef = {};\n\n  // we keep track of root blocks in order to update subsequent sibling links\n  var lastRootBlock = void 0;\n  return OrderedMap(blockMap.withMutations(function (blockMapState) {\n    blockMapState.forEach(function (block, index) {\n      var oldKey = block.getKey();\n      var nextKey = block.getNextSiblingKey();\n      var prevKey = block.getPrevSiblingKey();\n      var childrenKeys = block.getChildKeys();\n      var parentKey = block.getParentKey();\n\n      // new key that we will use to build linking\n      var key = generateRandomKey();\n\n      // we will add it here to re-use it later\n      newKeysRef[oldKey] = key;\n      if (nextKey) {\n        var nextBlock = blockMapState.get(nextKey);\n        if (nextBlock) {\n          blockMapState.setIn([nextKey, 'prevSibling'], key);\n        } else {\n          // this can happen when generating random keys for fragments\n          blockMapState.setIn([oldKey, 'nextSibling'], null);\n        }\n      }\n      if (prevKey) {\n        var prevBlock = blockMapState.get(prevKey);\n        if (prevBlock) {\n          blockMapState.setIn([prevKey, 'nextSibling'], key);\n        } else {\n          // this can happen when generating random keys for fragments\n          blockMapState.setIn([oldKey, 'prevSibling'], null);\n        }\n      }\n      if (parentKey && blockMapState.get(parentKey)) {\n        var parentBlock = blockMapState.get(parentKey);\n        var parentChildrenList = parentBlock.getChildKeys();\n        blockMapState.setIn([parentKey, 'children'], parentChildrenList.set(parentChildrenList.indexOf(block.getKey()), key));\n      } else {\n        // blocks will then be treated as root block nodes\n        blockMapState.setIn([oldKey, 'parent'], null);\n        if (lastRootBlock) {\n          blockMapState.setIn([lastRootBlock.getKey(), 'nextSibling'], key);\n          blockMapState.setIn([oldKey, 'prevSibling'], newKeysRef[lastRootBlock.getKey()]);\n        }\n        lastRootBlock = blockMapState.get(oldKey);\n      }\n      childrenKeys.forEach(function (childKey) {\n        var childBlock = blockMapState.get(childKey);\n        if (childBlock) {\n          blockMapState.setIn([childKey, 'parent'], key);\n        } else {\n          blockMapState.setIn([oldKey, 'children'], block.getChildKeys().filter(function (child) {\n            return child !== childKey;\n          }));\n        }\n      });\n    });\n  }).toArray().map(function (block) {\n    return [newKeysRef[block.getKey()], block.set('key', newKeysRef[block.getKey()])];\n  }));\n};\nvar randomizeContentBlockKeys = function randomizeContentBlockKeys(blockMap) {\n  return OrderedMap(blockMap.toArray().map(function (block) {\n    var key = generateRandomKey();\n    return [key, block.set('key', key)];\n  }));\n};\nvar randomizeBlockMapKeys = function randomizeBlockMapKeys(blockMap) {\n  var isTreeBasedBlockMap = blockMap.first() instanceof ContentBlockNode;\n  if (!isTreeBasedBlockMap) {\n    return randomizeContentBlockKeys(blockMap);\n  }\n  return randomizeContentBlockNodeKeys(blockMap);\n};\nmodule.exports = randomizeBlockMapKeys;","map":{"version":3,"names":["ContentBlockNode","require","Immutable","generateRandomKey","OrderedMap","randomizeContentBlockNodeKeys","blockMap","newKeysRef","lastRootBlock","withMutations","blockMapState","forEach","block","index","oldKey","getKey","nextKey","getNextSiblingKey","prevKey","getPrevSiblingKey","childrenKeys","getChildKeys","parentKey","getParentKey","key","nextBlock","get","setIn","prevBlock","parentBlock","parentChildrenList","set","indexOf","childKey","childBlock","filter","child","toArray","map","randomizeContentBlockKeys","randomizeBlockMapKeys","isTreeBasedBlockMap","first","module","exports"],"sources":["/Users/zhangqiang/Documents/GitHub/frontEnd-all-knowledge/examples/react/a08antd带编辑的表格/node_modules/rc-editor-core/node_modules/draft-js/lib/randomizeBlockMapKeys.js"],"sourcesContent":["/**\n * Copyright (c) 2013-present, Facebook, Inc.\n * All rights reserved.\n *\n * This source code is licensed under the BSD-style license found in the\n * LICENSE file in the root directory of this source tree. An additional grant\n * of patent rights can be found in the PATENTS file in the same directory.\n *\n * @providesModule randomizeBlockMapKeys\n * @format\n * \n */\n\n'use strict';\n\nvar ContentBlockNode = require('./ContentBlockNode');\nvar Immutable = require('immutable');\n\nvar generateRandomKey = require('./generateRandomKey');\n\nvar OrderedMap = Immutable.OrderedMap;\n\n\nvar randomizeContentBlockNodeKeys = function randomizeContentBlockNodeKeys(blockMap) {\n  var newKeysRef = {};\n\n  // we keep track of root blocks in order to update subsequent sibling links\n  var lastRootBlock = void 0;\n\n  return OrderedMap(blockMap.withMutations(function (blockMapState) {\n    blockMapState.forEach(function (block, index) {\n      var oldKey = block.getKey();\n      var nextKey = block.getNextSiblingKey();\n      var prevKey = block.getPrevSiblingKey();\n      var childrenKeys = block.getChildKeys();\n      var parentKey = block.getParentKey();\n\n      // new key that we will use to build linking\n      var key = generateRandomKey();\n\n      // we will add it here to re-use it later\n      newKeysRef[oldKey] = key;\n\n      if (nextKey) {\n        var nextBlock = blockMapState.get(nextKey);\n        if (nextBlock) {\n          blockMapState.setIn([nextKey, 'prevSibling'], key);\n        } else {\n          // this can happen when generating random keys for fragments\n          blockMapState.setIn([oldKey, 'nextSibling'], null);\n        }\n      }\n\n      if (prevKey) {\n        var prevBlock = blockMapState.get(prevKey);\n        if (prevBlock) {\n          blockMapState.setIn([prevKey, 'nextSibling'], key);\n        } else {\n          // this can happen when generating random keys for fragments\n          blockMapState.setIn([oldKey, 'prevSibling'], null);\n        }\n      }\n\n      if (parentKey && blockMapState.get(parentKey)) {\n        var parentBlock = blockMapState.get(parentKey);\n        var parentChildrenList = parentBlock.getChildKeys();\n        blockMapState.setIn([parentKey, 'children'], parentChildrenList.set(parentChildrenList.indexOf(block.getKey()), key));\n      } else {\n        // blocks will then be treated as root block nodes\n        blockMapState.setIn([oldKey, 'parent'], null);\n\n        if (lastRootBlock) {\n          blockMapState.setIn([lastRootBlock.getKey(), 'nextSibling'], key);\n          blockMapState.setIn([oldKey, 'prevSibling'], newKeysRef[lastRootBlock.getKey()]);\n        }\n\n        lastRootBlock = blockMapState.get(oldKey);\n      }\n\n      childrenKeys.forEach(function (childKey) {\n        var childBlock = blockMapState.get(childKey);\n        if (childBlock) {\n          blockMapState.setIn([childKey, 'parent'], key);\n        } else {\n          blockMapState.setIn([oldKey, 'children'], block.getChildKeys().filter(function (child) {\n            return child !== childKey;\n          }));\n        }\n      });\n    });\n  }).toArray().map(function (block) {\n    return [newKeysRef[block.getKey()], block.set('key', newKeysRef[block.getKey()])];\n  }));\n};\n\nvar randomizeContentBlockKeys = function randomizeContentBlockKeys(blockMap) {\n  return OrderedMap(blockMap.toArray().map(function (block) {\n    var key = generateRandomKey();\n    return [key, block.set('key', key)];\n  }));\n};\n\nvar randomizeBlockMapKeys = function randomizeBlockMapKeys(blockMap) {\n  var isTreeBasedBlockMap = blockMap.first() instanceof ContentBlockNode;\n\n  if (!isTreeBasedBlockMap) {\n    return randomizeContentBlockKeys(blockMap);\n  }\n\n  return randomizeContentBlockNodeKeys(blockMap);\n};\n\nmodule.exports = randomizeBlockMapKeys;"],"mappings":"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"},"metadata":{},"sourceType":"script","externalDependencies":[]}