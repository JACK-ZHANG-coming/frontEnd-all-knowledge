{"ast":null,"code":"/**\n * Copyright (c) 2013-present, Facebook, Inc.\n * All rights reserved.\n *\n * This source code is licensed under the BSD-style license found in the\n * LICENSE file in the root directory of this source tree. An additional grant\n * of patent rights can be found in the PATENTS file in the same directory.\n *\n * @providesModule editOnPaste\n * @format\n * \n */\n\n'use strict';\n\nvar BlockMapBuilder = require('./BlockMapBuilder');\nvar CharacterMetadata = require('./CharacterMetadata');\nvar DataTransfer = require('fbjs/lib/DataTransfer');\nvar DraftModifier = require('./DraftModifier');\nvar DraftPasteProcessor = require('./DraftPasteProcessor');\nvar EditorState = require('./EditorState');\nvar RichTextEditorUtil = require('./RichTextEditorUtil');\nvar getEntityKeyForSelection = require('./getEntityKeyForSelection');\nvar getTextContentFromFiles = require('./getTextContentFromFiles');\nvar isEventHandled = require('./isEventHandled');\nvar splitTextIntoTextBlocks = require('./splitTextIntoTextBlocks');\n\n/**\n * Paste content.\n */\nfunction editOnPaste(editor, e) {\n  e.preventDefault();\n  var data = new DataTransfer(e.clipboardData);\n\n  // Get files, unless this is likely to be a string the user wants inline.\n  if (!data.isRichText()) {\n    var files = data.getFiles();\n    var defaultFileText = data.getText();\n    if (files.length > 0) {\n      // Allow customized paste handling for images, etc. Otherwise, fall\n      // through to insert text contents into the editor.\n      if (editor.props.handlePastedFiles && isEventHandled(editor.props.handlePastedFiles(files))) {\n        return;\n      }\n      getTextContentFromFiles(files, function ( /*string*/fileText) {\n        fileText = fileText || defaultFileText;\n        if (!fileText) {\n          return;\n        }\n        var editorState = editor._latestEditorState;\n        var blocks = splitTextIntoTextBlocks(fileText);\n        var character = CharacterMetadata.create({\n          style: editorState.getCurrentInlineStyle(),\n          entity: getEntityKeyForSelection(editorState.getCurrentContent(), editorState.getSelection())\n        });\n        var currentBlockType = RichTextEditorUtil.getCurrentBlockType(editorState);\n        var text = DraftPasteProcessor.processText(blocks, character, currentBlockType);\n        var fragment = BlockMapBuilder.createFromArray(text);\n        var withInsertedText = DraftModifier.replaceWithFragment(editorState.getCurrentContent(), editorState.getSelection(), fragment);\n        editor.update(EditorState.push(editorState, withInsertedText, 'insert-fragment'));\n      });\n      return;\n    }\n  }\n  var textBlocks = [];\n  var text = data.getText();\n  var html = data.getHTML();\n  var editorState = editor._latestEditorState;\n  if (editor.props.handlePastedText && isEventHandled(editor.props.handlePastedText(text, html, editorState))) {\n    return;\n  }\n  if (text) {\n    textBlocks = splitTextIntoTextBlocks(text);\n  }\n  if (!editor.props.stripPastedStyles) {\n    // If the text from the paste event is rich content that matches what we\n    // already have on the internal clipboard, assume that we should just use\n    // the clipboard fragment for the paste. This will allow us to preserve\n    // styling and entities, if any are present. Note that newlines are\n    // stripped during comparison -- this is because copy/paste within the\n    // editor in Firefox and IE will not include empty lines. The resulting\n    // paste will preserve the newlines correctly.\n    var internalClipboard = editor.getClipboard();\n    if (data.isRichText() && internalClipboard) {\n      if (\n      // If the editorKey is present in the pasted HTML, it should be safe to\n      // assume this is an internal paste.\n      html.indexOf(editor.getEditorKey()) !== -1 ||\n      // The copy may have been made within a single block, in which case the\n      // editor key won't be part of the paste. In this case, just check\n      // whether the pasted text matches the internal clipboard.\n      textBlocks.length === 1 && internalClipboard.size === 1 && internalClipboard.first().getText() === text) {\n        editor.update(insertFragment(editor._latestEditorState, internalClipboard));\n        return;\n      }\n    } else if (internalClipboard && data.types.includes('com.apple.webarchive') && !data.types.includes('text/html') && areTextBlocksAndClipboardEqual(textBlocks, internalClipboard)) {\n      // Safari does not properly store text/html in some cases.\n      // Use the internalClipboard if present and equal to what is on\n      // the clipboard. See https://bugs.webkit.org/show_bug.cgi?id=19893.\n      editor.update(insertFragment(editor._latestEditorState, internalClipboard));\n      return;\n    }\n\n    // If there is html paste data, try to parse that.\n    if (html) {\n      var htmlFragment = DraftPasteProcessor.processHTML(html, editor.props.blockRenderMap);\n      if (htmlFragment) {\n        var contentBlocks = htmlFragment.contentBlocks,\n          entityMap = htmlFragment.entityMap;\n        if (contentBlocks) {\n          var htmlMap = BlockMapBuilder.createFromArray(contentBlocks);\n          editor.update(insertFragment(editor._latestEditorState, htmlMap, entityMap));\n          return;\n        }\n      }\n    }\n\n    // Otherwise, create a new fragment from our pasted text. Also\n    // empty the internal clipboard, since it's no longer valid.\n    editor.setClipboard(null);\n  }\n  if (textBlocks.length) {\n    var character = CharacterMetadata.create({\n      style: editorState.getCurrentInlineStyle(),\n      entity: getEntityKeyForSelection(editorState.getCurrentContent(), editorState.getSelection())\n    });\n    var currentBlockType = RichTextEditorUtil.getCurrentBlockType(editorState);\n    var textFragment = DraftPasteProcessor.processText(textBlocks, character, currentBlockType);\n    var textMap = BlockMapBuilder.createFromArray(textFragment);\n    editor.update(insertFragment(editor._latestEditorState, textMap));\n  }\n}\nfunction insertFragment(editorState, fragment, entityMap) {\n  var newContent = DraftModifier.replaceWithFragment(editorState.getCurrentContent(), editorState.getSelection(), fragment);\n  // TODO: merge the entity map once we stop using DraftEntity\n  // like this:\n  // const mergedEntityMap = newContent.getEntityMap().merge(entityMap);\n\n  return EditorState.push(editorState, newContent.set('entityMap', entityMap), 'insert-fragment');\n}\nfunction areTextBlocksAndClipboardEqual(textBlocks, blockMap) {\n  return textBlocks.length === blockMap.size && blockMap.valueSeq().every(function (block, ii) {\n    return block.getText() === textBlocks[ii];\n  });\n}\nmodule.exports = editOnPaste;","map":{"version":3,"names":["BlockMapBuilder","require","CharacterMetadata","DataTransfer","DraftModifier","DraftPasteProcessor","EditorState","RichTextEditorUtil","getEntityKeyForSelection","getTextContentFromFiles","isEventHandled","splitTextIntoTextBlocks","editOnPaste","editor","e","preventDefault","data","clipboardData","isRichText","files","getFiles","defaultFileText","getText","length","props","handlePastedFiles","fileText","editorState","_latestEditorState","blocks","character","create","style","getCurrentInlineStyle","entity","getCurrentContent","getSelection","currentBlockType","getCurrentBlockType","text","processText","fragment","createFromArray","withInsertedText","replaceWithFragment","update","push","textBlocks","html","getHTML","handlePastedText","stripPastedStyles","internalClipboard","getClipboard","indexOf","getEditorKey","size","first","insertFragment","types","includes","areTextBlocksAndClipboardEqual","htmlFragment","processHTML","blockRenderMap","contentBlocks","entityMap","htmlMap","setClipboard","textFragment","textMap","newContent","set","blockMap","valueSeq","every","block","ii","module","exports"],"sources":["/Users/zhangqiang/Documents/GitHub/frontEnd-all-knowledge/examples/react/a08antd带编辑的表格/node_modules/rc-editor-mention/node_modules/draft-js/lib/editOnPaste.js"],"sourcesContent":["/**\n * Copyright (c) 2013-present, Facebook, Inc.\n * All rights reserved.\n *\n * This source code is licensed under the BSD-style license found in the\n * LICENSE file in the root directory of this source tree. An additional grant\n * of patent rights can be found in the PATENTS file in the same directory.\n *\n * @providesModule editOnPaste\n * @format\n * \n */\n\n'use strict';\n\nvar BlockMapBuilder = require('./BlockMapBuilder');\nvar CharacterMetadata = require('./CharacterMetadata');\nvar DataTransfer = require('fbjs/lib/DataTransfer');\nvar DraftModifier = require('./DraftModifier');\nvar DraftPasteProcessor = require('./DraftPasteProcessor');\nvar EditorState = require('./EditorState');\nvar RichTextEditorUtil = require('./RichTextEditorUtil');\n\nvar getEntityKeyForSelection = require('./getEntityKeyForSelection');\nvar getTextContentFromFiles = require('./getTextContentFromFiles');\nvar isEventHandled = require('./isEventHandled');\nvar splitTextIntoTextBlocks = require('./splitTextIntoTextBlocks');\n\n/**\n * Paste content.\n */\nfunction editOnPaste(editor, e) {\n  e.preventDefault();\n  var data = new DataTransfer(e.clipboardData);\n\n  // Get files, unless this is likely to be a string the user wants inline.\n  if (!data.isRichText()) {\n    var files = data.getFiles();\n    var defaultFileText = data.getText();\n    if (files.length > 0) {\n      // Allow customized paste handling for images, etc. Otherwise, fall\n      // through to insert text contents into the editor.\n      if (editor.props.handlePastedFiles && isEventHandled(editor.props.handlePastedFiles(files))) {\n        return;\n      }\n\n      getTextContentFromFiles(files, function ( /*string*/fileText) {\n        fileText = fileText || defaultFileText;\n        if (!fileText) {\n          return;\n        }\n\n        var editorState = editor._latestEditorState;\n        var blocks = splitTextIntoTextBlocks(fileText);\n        var character = CharacterMetadata.create({\n          style: editorState.getCurrentInlineStyle(),\n          entity: getEntityKeyForSelection(editorState.getCurrentContent(), editorState.getSelection())\n        });\n        var currentBlockType = RichTextEditorUtil.getCurrentBlockType(editorState);\n\n        var text = DraftPasteProcessor.processText(blocks, character, currentBlockType);\n        var fragment = BlockMapBuilder.createFromArray(text);\n\n        var withInsertedText = DraftModifier.replaceWithFragment(editorState.getCurrentContent(), editorState.getSelection(), fragment);\n\n        editor.update(EditorState.push(editorState, withInsertedText, 'insert-fragment'));\n      });\n\n      return;\n    }\n  }\n\n  var textBlocks = [];\n  var text = data.getText();\n  var html = data.getHTML();\n  var editorState = editor._latestEditorState;\n\n  if (editor.props.handlePastedText && isEventHandled(editor.props.handlePastedText(text, html, editorState))) {\n    return;\n  }\n\n  if (text) {\n    textBlocks = splitTextIntoTextBlocks(text);\n  }\n\n  if (!editor.props.stripPastedStyles) {\n    // If the text from the paste event is rich content that matches what we\n    // already have on the internal clipboard, assume that we should just use\n    // the clipboard fragment for the paste. This will allow us to preserve\n    // styling and entities, if any are present. Note that newlines are\n    // stripped during comparison -- this is because copy/paste within the\n    // editor in Firefox and IE will not include empty lines. The resulting\n    // paste will preserve the newlines correctly.\n    var internalClipboard = editor.getClipboard();\n    if (data.isRichText() && internalClipboard) {\n      if (\n      // If the editorKey is present in the pasted HTML, it should be safe to\n      // assume this is an internal paste.\n      html.indexOf(editor.getEditorKey()) !== -1 ||\n      // The copy may have been made within a single block, in which case the\n      // editor key won't be part of the paste. In this case, just check\n      // whether the pasted text matches the internal clipboard.\n      textBlocks.length === 1 && internalClipboard.size === 1 && internalClipboard.first().getText() === text) {\n        editor.update(insertFragment(editor._latestEditorState, internalClipboard));\n        return;\n      }\n    } else if (internalClipboard && data.types.includes('com.apple.webarchive') && !data.types.includes('text/html') && areTextBlocksAndClipboardEqual(textBlocks, internalClipboard)) {\n      // Safari does not properly store text/html in some cases.\n      // Use the internalClipboard if present and equal to what is on\n      // the clipboard. See https://bugs.webkit.org/show_bug.cgi?id=19893.\n      editor.update(insertFragment(editor._latestEditorState, internalClipboard));\n      return;\n    }\n\n    // If there is html paste data, try to parse that.\n    if (html) {\n      var htmlFragment = DraftPasteProcessor.processHTML(html, editor.props.blockRenderMap);\n      if (htmlFragment) {\n        var contentBlocks = htmlFragment.contentBlocks,\n            entityMap = htmlFragment.entityMap;\n\n        if (contentBlocks) {\n          var htmlMap = BlockMapBuilder.createFromArray(contentBlocks);\n          editor.update(insertFragment(editor._latestEditorState, htmlMap, entityMap));\n          return;\n        }\n      }\n    }\n\n    // Otherwise, create a new fragment from our pasted text. Also\n    // empty the internal clipboard, since it's no longer valid.\n    editor.setClipboard(null);\n  }\n\n  if (textBlocks.length) {\n    var character = CharacterMetadata.create({\n      style: editorState.getCurrentInlineStyle(),\n      entity: getEntityKeyForSelection(editorState.getCurrentContent(), editorState.getSelection())\n    });\n\n    var currentBlockType = RichTextEditorUtil.getCurrentBlockType(editorState);\n\n    var textFragment = DraftPasteProcessor.processText(textBlocks, character, currentBlockType);\n\n    var textMap = BlockMapBuilder.createFromArray(textFragment);\n    editor.update(insertFragment(editor._latestEditorState, textMap));\n  }\n}\n\nfunction insertFragment(editorState, fragment, entityMap) {\n  var newContent = DraftModifier.replaceWithFragment(editorState.getCurrentContent(), editorState.getSelection(), fragment);\n  // TODO: merge the entity map once we stop using DraftEntity\n  // like this:\n  // const mergedEntityMap = newContent.getEntityMap().merge(entityMap);\n\n  return EditorState.push(editorState, newContent.set('entityMap', entityMap), 'insert-fragment');\n}\n\nfunction areTextBlocksAndClipboardEqual(textBlocks, blockMap) {\n  return textBlocks.length === blockMap.size && blockMap.valueSeq().every(function (block, ii) {\n    return block.getText() === textBlocks[ii];\n  });\n}\n\nmodule.exports = editOnPaste;"],"mappings":"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"},"metadata":{},"sourceType":"script","externalDependencies":[]}