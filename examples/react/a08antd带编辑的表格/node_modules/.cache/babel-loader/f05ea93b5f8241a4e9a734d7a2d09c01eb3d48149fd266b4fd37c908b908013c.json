{"ast":null,"code":"/**\n * Copyright (c) 2013-present, Facebook, Inc.\n * All rights reserved.\n *\n * This source code is licensed under the BSD-style license found in the\n * LICENSE file in the root directory of this source tree. An additional grant\n * of patent rights can be found in the PATENTS file in the same directory.\n *\n * @providesModule getCharacterRemovalRange\n * @format\n * \n */\n\n'use strict';\n\nvar DraftEntitySegments = require('./DraftEntitySegments');\nvar getRangesForDraftEntity = require('./getRangesForDraftEntity');\nvar invariant = require('fbjs/lib/invariant');\n\n/**\n * Given a SelectionState and a removal direction, determine the entire range\n * that should be removed from a ContentState. This is based on any entities\n * within the target, with their `mutability` values taken into account.\n *\n * For instance, if we are attempting to remove part of an \"immutable\" entity\n * range, the entire entity must be removed. The returned `SelectionState`\n * will be adjusted accordingly.\n */\nfunction getCharacterRemovalRange(entityMap, startBlock, endBlock, selectionState, direction) {\n  var start = selectionState.getStartOffset();\n  var end = selectionState.getEndOffset();\n  var startEntityKey = startBlock.getEntityAt(start);\n  var endEntityKey = endBlock.getEntityAt(end - 1);\n  if (!startEntityKey && !endEntityKey) {\n    return selectionState;\n  }\n  var newSelectionState = selectionState;\n  if (startEntityKey && startEntityKey === endEntityKey) {\n    newSelectionState = getEntityRemovalRange(entityMap, startBlock, newSelectionState, direction, startEntityKey, true, true);\n  } else if (startEntityKey && endEntityKey) {\n    var startSelectionState = getEntityRemovalRange(entityMap, startBlock, newSelectionState, direction, startEntityKey, false, true);\n    var endSelectionState = getEntityRemovalRange(entityMap, endBlock, newSelectionState, direction, endEntityKey, false, false);\n    newSelectionState = newSelectionState.merge({\n      anchorOffset: startSelectionState.getAnchorOffset(),\n      focusOffset: endSelectionState.getFocusOffset(),\n      isBackward: false\n    });\n  } else if (startEntityKey) {\n    var _startSelectionState = getEntityRemovalRange(entityMap, startBlock, newSelectionState, direction, startEntityKey, false, true);\n    newSelectionState = newSelectionState.merge({\n      anchorOffset: _startSelectionState.getStartOffset(),\n      isBackward: false\n    });\n  } else if (endEntityKey) {\n    var _endSelectionState = getEntityRemovalRange(entityMap, endBlock, newSelectionState, direction, endEntityKey, false, false);\n    newSelectionState = newSelectionState.merge({\n      focusOffset: _endSelectionState.getEndOffset(),\n      isBackward: false\n    });\n  }\n  return newSelectionState;\n}\nfunction getEntityRemovalRange(entityMap, block, selectionState, direction, entityKey, isEntireSelectionWithinEntity, isEntityAtStart) {\n  var start = selectionState.getStartOffset();\n  var end = selectionState.getEndOffset();\n  var entity = entityMap.__get(entityKey);\n  var mutability = entity.getMutability();\n  var sideToConsider = isEntityAtStart ? start : end;\n\n  // `MUTABLE` entities can just have the specified range of text removed\n  // directly. No adjustments are needed.\n  if (mutability === 'MUTABLE') {\n    return selectionState;\n  }\n\n  // Find the entity range that overlaps with our removal range.\n  var entityRanges = getRangesForDraftEntity(block, entityKey).filter(function (range) {\n    return sideToConsider <= range.end && sideToConsider >= range.start;\n  });\n  !(entityRanges.length == 1) ? process.env.NODE_ENV !== 'production' ? invariant(false, 'There should only be one entity range within this removal range.') : invariant(false) : void 0;\n  var entityRange = entityRanges[0];\n\n  // For `IMMUTABLE` entity types, we will remove the entire entity range.\n  if (mutability === 'IMMUTABLE') {\n    return selectionState.merge({\n      anchorOffset: entityRange.start,\n      focusOffset: entityRange.end,\n      isBackward: false\n    });\n  }\n\n  // For `SEGMENTED` entity types, determine the appropriate segment to\n  // remove.\n  if (!isEntireSelectionWithinEntity) {\n    if (isEntityAtStart) {\n      end = entityRange.end;\n    } else {\n      start = entityRange.start;\n    }\n  }\n  var removalRange = DraftEntitySegments.getRemovalRange(start, end, block.getText().slice(entityRange.start, entityRange.end), entityRange.start, direction);\n  return selectionState.merge({\n    anchorOffset: removalRange.start,\n    focusOffset: removalRange.end,\n    isBackward: false\n  });\n}\nmodule.exports = getCharacterRemovalRange;","map":{"version":3,"names":["DraftEntitySegments","require","getRangesForDraftEntity","invariant","getCharacterRemovalRange","entityMap","startBlock","endBlock","selectionState","direction","start","getStartOffset","end","getEndOffset","startEntityKey","getEntityAt","endEntityKey","newSelectionState","getEntityRemovalRange","startSelectionState","endSelectionState","merge","anchorOffset","getAnchorOffset","focusOffset","getFocusOffset","isBackward","_startSelectionState","_endSelectionState","block","entityKey","isEntireSelectionWithinEntity","isEntityAtStart","entity","__get","mutability","getMutability","sideToConsider","entityRanges","filter","range","length","process","env","NODE_ENV","entityRange","removalRange","getRemovalRange","getText","slice","module","exports"],"sources":["/Users/zhangqiang/Documents/GitHub/frontEnd-all-knowledge/examples/react/a08antd带编辑的表格/node_modules/rc-editor-core/node_modules/draft-js/lib/getCharacterRemovalRange.js"],"sourcesContent":["/**\n * Copyright (c) 2013-present, Facebook, Inc.\n * All rights reserved.\n *\n * This source code is licensed under the BSD-style license found in the\n * LICENSE file in the root directory of this source tree. An additional grant\n * of patent rights can be found in the PATENTS file in the same directory.\n *\n * @providesModule getCharacterRemovalRange\n * @format\n * \n */\n\n'use strict';\n\nvar DraftEntitySegments = require('./DraftEntitySegments');\n\nvar getRangesForDraftEntity = require('./getRangesForDraftEntity');\nvar invariant = require('fbjs/lib/invariant');\n\n/**\n * Given a SelectionState and a removal direction, determine the entire range\n * that should be removed from a ContentState. This is based on any entities\n * within the target, with their `mutability` values taken into account.\n *\n * For instance, if we are attempting to remove part of an \"immutable\" entity\n * range, the entire entity must be removed. The returned `SelectionState`\n * will be adjusted accordingly.\n */\nfunction getCharacterRemovalRange(entityMap, startBlock, endBlock, selectionState, direction) {\n  var start = selectionState.getStartOffset();\n  var end = selectionState.getEndOffset();\n  var startEntityKey = startBlock.getEntityAt(start);\n  var endEntityKey = endBlock.getEntityAt(end - 1);\n  if (!startEntityKey && !endEntityKey) {\n    return selectionState;\n  }\n  var newSelectionState = selectionState;\n  if (startEntityKey && startEntityKey === endEntityKey) {\n    newSelectionState = getEntityRemovalRange(entityMap, startBlock, newSelectionState, direction, startEntityKey, true, true);\n  } else if (startEntityKey && endEntityKey) {\n    var startSelectionState = getEntityRemovalRange(entityMap, startBlock, newSelectionState, direction, startEntityKey, false, true);\n    var endSelectionState = getEntityRemovalRange(entityMap, endBlock, newSelectionState, direction, endEntityKey, false, false);\n    newSelectionState = newSelectionState.merge({\n      anchorOffset: startSelectionState.getAnchorOffset(),\n      focusOffset: endSelectionState.getFocusOffset(),\n      isBackward: false\n    });\n  } else if (startEntityKey) {\n    var _startSelectionState = getEntityRemovalRange(entityMap, startBlock, newSelectionState, direction, startEntityKey, false, true);\n    newSelectionState = newSelectionState.merge({\n      anchorOffset: _startSelectionState.getStartOffset(),\n      isBackward: false\n    });\n  } else if (endEntityKey) {\n    var _endSelectionState = getEntityRemovalRange(entityMap, endBlock, newSelectionState, direction, endEntityKey, false, false);\n    newSelectionState = newSelectionState.merge({\n      focusOffset: _endSelectionState.getEndOffset(),\n      isBackward: false\n    });\n  }\n  return newSelectionState;\n}\n\nfunction getEntityRemovalRange(entityMap, block, selectionState, direction, entityKey, isEntireSelectionWithinEntity, isEntityAtStart) {\n  var start = selectionState.getStartOffset();\n  var end = selectionState.getEndOffset();\n  var entity = entityMap.__get(entityKey);\n  var mutability = entity.getMutability();\n  var sideToConsider = isEntityAtStart ? start : end;\n\n  // `MUTABLE` entities can just have the specified range of text removed\n  // directly. No adjustments are needed.\n  if (mutability === 'MUTABLE') {\n    return selectionState;\n  }\n\n  // Find the entity range that overlaps with our removal range.\n  var entityRanges = getRangesForDraftEntity(block, entityKey).filter(function (range) {\n    return sideToConsider <= range.end && sideToConsider >= range.start;\n  });\n\n  !(entityRanges.length == 1) ? process.env.NODE_ENV !== 'production' ? invariant(false, 'There should only be one entity range within this removal range.') : invariant(false) : void 0;\n\n  var entityRange = entityRanges[0];\n\n  // For `IMMUTABLE` entity types, we will remove the entire entity range.\n  if (mutability === 'IMMUTABLE') {\n    return selectionState.merge({\n      anchorOffset: entityRange.start,\n      focusOffset: entityRange.end,\n      isBackward: false\n    });\n  }\n\n  // For `SEGMENTED` entity types, determine the appropriate segment to\n  // remove.\n  if (!isEntireSelectionWithinEntity) {\n    if (isEntityAtStart) {\n      end = entityRange.end;\n    } else {\n      start = entityRange.start;\n    }\n  }\n\n  var removalRange = DraftEntitySegments.getRemovalRange(start, end, block.getText().slice(entityRange.start, entityRange.end), entityRange.start, direction);\n\n  return selectionState.merge({\n    anchorOffset: removalRange.start,\n    focusOffset: removalRange.end,\n    isBackward: false\n  });\n}\n\nmodule.exports = getCharacterRemovalRange;"],"mappings":"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"},"metadata":{},"sourceType":"script","externalDependencies":[]}