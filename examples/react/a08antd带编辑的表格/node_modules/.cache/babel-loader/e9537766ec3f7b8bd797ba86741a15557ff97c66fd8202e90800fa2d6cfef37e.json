{"ast":null,"code":"/**\n * Copyright (c) 2013-present, Facebook, Inc.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n * @typechecks\n */\n\n/**\n * Unicode-enabled replacesments for basic String functions.\n *\n * All the functions in this module assume that the input string is a valid\n * UTF-16 encoding of a Unicode sequence. If it's not the case, the behavior\n * will be undefined.\n *\n * WARNING: Since this module is typechecks-enforced, you may find new bugs\n * when replacing normal String functions with ones provided here.\n */\n\n'use strict';\n\nvar invariant = require('./invariant');\n\n// These two ranges are consecutive so anything in [HIGH_START, LOW_END] is a\n// surrogate code unit.\nvar SURROGATE_HIGH_START = 0xD800;\nvar SURROGATE_HIGH_END = 0xDBFF;\nvar SURROGATE_LOW_START = 0xDC00;\nvar SURROGATE_LOW_END = 0xDFFF;\nvar SURROGATE_UNITS_REGEX = /[\\uD800-\\uDFFF]/;\n\n/**\n * @param {number} codeUnit   A Unicode code-unit, in range [0, 0x10FFFF]\n * @return {boolean}          Whether code-unit is in a surrogate (hi/low) range\n */\nfunction isCodeUnitInSurrogateRange(codeUnit) {\n  return SURROGATE_HIGH_START <= codeUnit && codeUnit <= SURROGATE_LOW_END;\n}\n\n/**\n * Returns whether the two characters starting at `index` form a surrogate pair.\n * For example, given the string s = \"\\uD83D\\uDE0A\", (s, 0) returns true and\n * (s, 1) returns false.\n *\n * @param {string} str\n * @param {number} index\n * @return {boolean}\n */\nfunction isSurrogatePair(str, index) {\n  !(0 <= index && index < str.length) ? process.env.NODE_ENV !== 'production' ? invariant(false, 'isSurrogatePair: Invalid index %s for string length %s.', index, str.length) : invariant(false) : void 0;\n  if (index + 1 === str.length) {\n    return false;\n  }\n  var first = str.charCodeAt(index);\n  var second = str.charCodeAt(index + 1);\n  return SURROGATE_HIGH_START <= first && first <= SURROGATE_HIGH_END && SURROGATE_LOW_START <= second && second <= SURROGATE_LOW_END;\n}\n\n/**\n * @param {string} str  Non-empty string\n * @return {boolean}    True if the input includes any surrogate code units\n */\nfunction hasSurrogateUnit(str) {\n  return SURROGATE_UNITS_REGEX.test(str);\n}\n\n/**\n * Return the length of the original Unicode character at given position in the\n * String by looking into the UTF-16 code unit; that is equal to 1 for any\n * non-surrogate characters in BMP ([U+0000..U+D7FF] and [U+E000, U+FFFF]); and\n * returns 2 for the hi/low surrogates ([U+D800..U+DFFF]), which are in fact\n * representing non-BMP characters ([U+10000..U+10FFFF]).\n *\n * Examples:\n * - '\\u0020' => 1\n * - '\\u3020' => 1\n * - '\\uD835' => 2\n * - '\\uD835\\uDDEF' => 2\n * - '\\uDDEF' => 2\n *\n * @param {string} str  Non-empty string\n * @param {number} pos  Position in the string to look for one code unit\n * @return {number}      Number 1 or 2\n */\nfunction getUTF16Length(str, pos) {\n  return 1 + isCodeUnitInSurrogateRange(str.charCodeAt(pos));\n}\n\n/**\n * Fully Unicode-enabled replacement for String#length\n *\n * @param {string} str  Valid Unicode string\n * @return {number}     The number of Unicode characters in the string\n */\nfunction strlen(str) {\n  // Call the native functions if there's no surrogate char\n  if (!hasSurrogateUnit(str)) {\n    return str.length;\n  }\n  var len = 0;\n  for (var pos = 0; pos < str.length; pos += getUTF16Length(str, pos)) {\n    len++;\n  }\n  return len;\n}\n\n/**\n * Fully Unicode-enabled replacement for String#substr()\n *\n * @param {string} str      Valid Unicode string\n * @param {number} start    Location in Unicode sequence to begin extracting\n * @param {?number} length  The number of Unicode characters to extract\n *                          (default: to the end of the string)\n * @return {string}         Extracted sub-string\n */\nfunction substr(str, start, length) {\n  start = start || 0;\n  length = length === undefined ? Infinity : length || 0;\n\n  // Call the native functions if there's no surrogate char\n  if (!hasSurrogateUnit(str)) {\n    return str.substr(start, length);\n  }\n\n  // Obvious cases\n  var size = str.length;\n  if (size <= 0 || start > size || length <= 0) {\n    return '';\n  }\n\n  // Find the actual starting position\n  var posA = 0;\n  if (start > 0) {\n    for (; start > 0 && posA < size; start--) {\n      posA += getUTF16Length(str, posA);\n    }\n    if (posA >= size) {\n      return '';\n    }\n  } else if (start < 0) {\n    for (posA = size; start < 0 && 0 < posA; start++) {\n      posA -= getUTF16Length(str, posA - 1);\n    }\n    if (posA < 0) {\n      posA = 0;\n    }\n  }\n\n  // Find the actual ending position\n  var posB = size;\n  if (length < size) {\n    for (posB = posA; length > 0 && posB < size; length--) {\n      posB += getUTF16Length(str, posB);\n    }\n  }\n  return str.substring(posA, posB);\n}\n\n/**\n * Fully Unicode-enabled replacement for String#substring()\n *\n * @param {string} str    Valid Unicode string\n * @param {number} start  Location in Unicode sequence to begin extracting\n * @param {?number} end   Location in Unicode sequence to end extracting\n *                        (default: end of the string)\n * @return {string}       Extracted sub-string\n */\nfunction substring(str, start, end) {\n  start = start || 0;\n  end = end === undefined ? Infinity : end || 0;\n  if (start < 0) {\n    start = 0;\n  }\n  if (end < 0) {\n    end = 0;\n  }\n  var length = Math.abs(end - start);\n  start = start < end ? start : end;\n  return substr(str, start, length);\n}\n\n/**\n * Get a list of Unicode code-points from a String\n *\n * @param {string} str        Valid Unicode string\n * @return {array<number>}    A list of code-points in [0..0x10FFFF]\n */\nfunction getCodePoints(str) {\n  var codePoints = [];\n  for (var pos = 0; pos < str.length; pos += getUTF16Length(str, pos)) {\n    codePoints.push(str.codePointAt(pos));\n  }\n  return codePoints;\n}\nvar UnicodeUtils = {\n  getCodePoints: getCodePoints,\n  getUTF16Length: getUTF16Length,\n  hasSurrogateUnit: hasSurrogateUnit,\n  isCodeUnitInSurrogateRange: isCodeUnitInSurrogateRange,\n  isSurrogatePair: isSurrogatePair,\n  strlen: strlen,\n  substring: substring,\n  substr: substr\n};\nmodule.exports = UnicodeUtils;","map":{"version":3,"names":["invariant","require","SURROGATE_HIGH_START","SURROGATE_HIGH_END","SURROGATE_LOW_START","SURROGATE_LOW_END","SURROGATE_UNITS_REGEX","isCodeUnitInSurrogateRange","codeUnit","isSurrogatePair","str","index","length","process","env","NODE_ENV","first","charCodeAt","second","hasSurrogateUnit","test","getUTF16Length","pos","strlen","len","substr","start","undefined","Infinity","size","posA","posB","substring","end","Math","abs","getCodePoints","codePoints","push","codePointAt","UnicodeUtils","module","exports"],"sources":["/Users/zhangqiang/Documents/GitHub/frontEnd-all-knowledge/examples/react/a08antd带编辑的表格/node_modules/fbjs/lib/UnicodeUtils.js"],"sourcesContent":["/**\n * Copyright (c) 2013-present, Facebook, Inc.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n * @typechecks\n */\n\n/**\n * Unicode-enabled replacesments for basic String functions.\n *\n * All the functions in this module assume that the input string is a valid\n * UTF-16 encoding of a Unicode sequence. If it's not the case, the behavior\n * will be undefined.\n *\n * WARNING: Since this module is typechecks-enforced, you may find new bugs\n * when replacing normal String functions with ones provided here.\n */\n\n'use strict';\n\nvar invariant = require('./invariant');\n\n// These two ranges are consecutive so anything in [HIGH_START, LOW_END] is a\n// surrogate code unit.\nvar SURROGATE_HIGH_START = 0xD800;\nvar SURROGATE_HIGH_END = 0xDBFF;\nvar SURROGATE_LOW_START = 0xDC00;\nvar SURROGATE_LOW_END = 0xDFFF;\nvar SURROGATE_UNITS_REGEX = /[\\uD800-\\uDFFF]/;\n\n/**\n * @param {number} codeUnit   A Unicode code-unit, in range [0, 0x10FFFF]\n * @return {boolean}          Whether code-unit is in a surrogate (hi/low) range\n */\nfunction isCodeUnitInSurrogateRange(codeUnit) {\n  return SURROGATE_HIGH_START <= codeUnit && codeUnit <= SURROGATE_LOW_END;\n}\n\n/**\n * Returns whether the two characters starting at `index` form a surrogate pair.\n * For example, given the string s = \"\\uD83D\\uDE0A\", (s, 0) returns true and\n * (s, 1) returns false.\n *\n * @param {string} str\n * @param {number} index\n * @return {boolean}\n */\nfunction isSurrogatePair(str, index) {\n  !(0 <= index && index < str.length) ? process.env.NODE_ENV !== 'production' ? invariant(false, 'isSurrogatePair: Invalid index %s for string length %s.', index, str.length) : invariant(false) : void 0;\n  if (index + 1 === str.length) {\n    return false;\n  }\n  var first = str.charCodeAt(index);\n  var second = str.charCodeAt(index + 1);\n  return SURROGATE_HIGH_START <= first && first <= SURROGATE_HIGH_END && SURROGATE_LOW_START <= second && second <= SURROGATE_LOW_END;\n}\n\n/**\n * @param {string} str  Non-empty string\n * @return {boolean}    True if the input includes any surrogate code units\n */\nfunction hasSurrogateUnit(str) {\n  return SURROGATE_UNITS_REGEX.test(str);\n}\n\n/**\n * Return the length of the original Unicode character at given position in the\n * String by looking into the UTF-16 code unit; that is equal to 1 for any\n * non-surrogate characters in BMP ([U+0000..U+D7FF] and [U+E000, U+FFFF]); and\n * returns 2 for the hi/low surrogates ([U+D800..U+DFFF]), which are in fact\n * representing non-BMP characters ([U+10000..U+10FFFF]).\n *\n * Examples:\n * - '\\u0020' => 1\n * - '\\u3020' => 1\n * - '\\uD835' => 2\n * - '\\uD835\\uDDEF' => 2\n * - '\\uDDEF' => 2\n *\n * @param {string} str  Non-empty string\n * @param {number} pos  Position in the string to look for one code unit\n * @return {number}      Number 1 or 2\n */\nfunction getUTF16Length(str, pos) {\n  return 1 + isCodeUnitInSurrogateRange(str.charCodeAt(pos));\n}\n\n/**\n * Fully Unicode-enabled replacement for String#length\n *\n * @param {string} str  Valid Unicode string\n * @return {number}     The number of Unicode characters in the string\n */\nfunction strlen(str) {\n  // Call the native functions if there's no surrogate char\n  if (!hasSurrogateUnit(str)) {\n    return str.length;\n  }\n\n  var len = 0;\n  for (var pos = 0; pos < str.length; pos += getUTF16Length(str, pos)) {\n    len++;\n  }\n  return len;\n}\n\n/**\n * Fully Unicode-enabled replacement for String#substr()\n *\n * @param {string} str      Valid Unicode string\n * @param {number} start    Location in Unicode sequence to begin extracting\n * @param {?number} length  The number of Unicode characters to extract\n *                          (default: to the end of the string)\n * @return {string}         Extracted sub-string\n */\nfunction substr(str, start, length) {\n  start = start || 0;\n  length = length === undefined ? Infinity : length || 0;\n\n  // Call the native functions if there's no surrogate char\n  if (!hasSurrogateUnit(str)) {\n    return str.substr(start, length);\n  }\n\n  // Obvious cases\n  var size = str.length;\n  if (size <= 0 || start > size || length <= 0) {\n    return '';\n  }\n\n  // Find the actual starting position\n  var posA = 0;\n  if (start > 0) {\n    for (; start > 0 && posA < size; start--) {\n      posA += getUTF16Length(str, posA);\n    }\n    if (posA >= size) {\n      return '';\n    }\n  } else if (start < 0) {\n    for (posA = size; start < 0 && 0 < posA; start++) {\n      posA -= getUTF16Length(str, posA - 1);\n    }\n    if (posA < 0) {\n      posA = 0;\n    }\n  }\n\n  // Find the actual ending position\n  var posB = size;\n  if (length < size) {\n    for (posB = posA; length > 0 && posB < size; length--) {\n      posB += getUTF16Length(str, posB);\n    }\n  }\n\n  return str.substring(posA, posB);\n}\n\n/**\n * Fully Unicode-enabled replacement for String#substring()\n *\n * @param {string} str    Valid Unicode string\n * @param {number} start  Location in Unicode sequence to begin extracting\n * @param {?number} end   Location in Unicode sequence to end extracting\n *                        (default: end of the string)\n * @return {string}       Extracted sub-string\n */\nfunction substring(str, start, end) {\n  start = start || 0;\n  end = end === undefined ? Infinity : end || 0;\n\n  if (start < 0) {\n    start = 0;\n  }\n  if (end < 0) {\n    end = 0;\n  }\n\n  var length = Math.abs(end - start);\n  start = start < end ? start : end;\n  return substr(str, start, length);\n}\n\n/**\n * Get a list of Unicode code-points from a String\n *\n * @param {string} str        Valid Unicode string\n * @return {array<number>}    A list of code-points in [0..0x10FFFF]\n */\nfunction getCodePoints(str) {\n  var codePoints = [];\n  for (var pos = 0; pos < str.length; pos += getUTF16Length(str, pos)) {\n    codePoints.push(str.codePointAt(pos));\n  }\n  return codePoints;\n}\n\nvar UnicodeUtils = {\n  getCodePoints: getCodePoints,\n  getUTF16Length: getUTF16Length,\n  hasSurrogateUnit: hasSurrogateUnit,\n  isCodeUnitInSurrogateRange: isCodeUnitInSurrogateRange,\n  isSurrogatePair: isSurrogatePair,\n  strlen: strlen,\n  substring: substring,\n  substr: substr\n};\n\nmodule.exports = UnicodeUtils;"],"mappings":"AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,YAAY;;AAEZ,IAAIA,SAAS,GAAGC,OAAO,CAAC,aAAa,CAAC;;AAEtC;AACA;AACA,IAAIC,oBAAoB,GAAG,MAAM;AACjC,IAAIC,kBAAkB,GAAG,MAAM;AAC/B,IAAIC,mBAAmB,GAAG,MAAM;AAChC,IAAIC,iBAAiB,GAAG,MAAM;AAC9B,IAAIC,qBAAqB,GAAG,iBAAiB;;AAE7C;AACA;AACA;AACA;AACA,SAASC,0BAA0BA,CAACC,QAAQ,EAAE;EAC5C,OAAON,oBAAoB,IAAIM,QAAQ,IAAIA,QAAQ,IAAIH,iBAAiB;AAC1E;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAASI,eAAeA,CAACC,GAAG,EAAEC,KAAK,EAAE;EACnC,EAAE,CAAC,IAAIA,KAAK,IAAIA,KAAK,GAAGD,GAAG,CAACE,MAAM,CAAC,GAAGC,OAAO,CAACC,GAAG,CAACC,QAAQ,KAAK,YAAY,GAAGf,SAAS,CAAC,KAAK,EAAE,yDAAyD,EAAEW,KAAK,EAAED,GAAG,CAACE,MAAM,CAAC,GAAGZ,SAAS,CAAC,KAAK,CAAC,GAAG,KAAK,CAAC;EACxM,IAAIW,KAAK,GAAG,CAAC,KAAKD,GAAG,CAACE,MAAM,EAAE;IAC5B,OAAO,KAAK;EACd;EACA,IAAII,KAAK,GAAGN,GAAG,CAACO,UAAU,CAACN,KAAK,CAAC;EACjC,IAAIO,MAAM,GAAGR,GAAG,CAACO,UAAU,CAACN,KAAK,GAAG,CAAC,CAAC;EACtC,OAAOT,oBAAoB,IAAIc,KAAK,IAAIA,KAAK,IAAIb,kBAAkB,IAAIC,mBAAmB,IAAIc,MAAM,IAAIA,MAAM,IAAIb,iBAAiB;AACrI;;AAEA;AACA;AACA;AACA;AACA,SAASc,gBAAgBA,CAACT,GAAG,EAAE;EAC7B,OAAOJ,qBAAqB,CAACc,IAAI,CAACV,GAAG,CAAC;AACxC;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAASW,cAAcA,CAACX,GAAG,EAAEY,GAAG,EAAE;EAChC,OAAO,CAAC,GAAGf,0BAA0B,CAACG,GAAG,CAACO,UAAU,CAACK,GAAG,CAAC,CAAC;AAC5D;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,SAASC,MAAMA,CAACb,GAAG,EAAE;EACnB;EACA,IAAI,CAACS,gBAAgB,CAACT,GAAG,CAAC,EAAE;IAC1B,OAAOA,GAAG,CAACE,MAAM;EACnB;EAEA,IAAIY,GAAG,GAAG,CAAC;EACX,KAAK,IAAIF,GAAG,GAAG,CAAC,EAAEA,GAAG,GAAGZ,GAAG,CAACE,MAAM,EAAEU,GAAG,IAAID,cAAc,CAACX,GAAG,EAAEY,GAAG,CAAC,EAAE;IACnEE,GAAG,EAAE;EACP;EACA,OAAOA,GAAG;AACZ;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAASC,MAAMA,CAACf,GAAG,EAAEgB,KAAK,EAAEd,MAAM,EAAE;EAClCc,KAAK,GAAGA,KAAK,IAAI,CAAC;EAClBd,MAAM,GAAGA,MAAM,KAAKe,SAAS,GAAGC,QAAQ,GAAGhB,MAAM,IAAI,CAAC;;EAEtD;EACA,IAAI,CAACO,gBAAgB,CAACT,GAAG,CAAC,EAAE;IAC1B,OAAOA,GAAG,CAACe,MAAM,CAACC,KAAK,EAAEd,MAAM,CAAC;EAClC;;EAEA;EACA,IAAIiB,IAAI,GAAGnB,GAAG,CAACE,MAAM;EACrB,IAAIiB,IAAI,IAAI,CAAC,IAAIH,KAAK,GAAGG,IAAI,IAAIjB,MAAM,IAAI,CAAC,EAAE;IAC5C,OAAO,EAAE;EACX;;EAEA;EACA,IAAIkB,IAAI,GAAG,CAAC;EACZ,IAAIJ,KAAK,GAAG,CAAC,EAAE;IACb,OAAOA,KAAK,GAAG,CAAC,IAAII,IAAI,GAAGD,IAAI,EAAEH,KAAK,EAAE,EAAE;MACxCI,IAAI,IAAIT,cAAc,CAACX,GAAG,EAAEoB,IAAI,CAAC;IACnC;IACA,IAAIA,IAAI,IAAID,IAAI,EAAE;MAChB,OAAO,EAAE;IACX;EACF,CAAC,MAAM,IAAIH,KAAK,GAAG,CAAC,EAAE;IACpB,KAAKI,IAAI,GAAGD,IAAI,EAAEH,KAAK,GAAG,CAAC,IAAI,CAAC,GAAGI,IAAI,EAAEJ,KAAK,EAAE,EAAE;MAChDI,IAAI,IAAIT,cAAc,CAACX,GAAG,EAAEoB,IAAI,GAAG,CAAC,CAAC;IACvC;IACA,IAAIA,IAAI,GAAG,CAAC,EAAE;MACZA,IAAI,GAAG,CAAC;IACV;EACF;;EAEA;EACA,IAAIC,IAAI,GAAGF,IAAI;EACf,IAAIjB,MAAM,GAAGiB,IAAI,EAAE;IACjB,KAAKE,IAAI,GAAGD,IAAI,EAAElB,MAAM,GAAG,CAAC,IAAImB,IAAI,GAAGF,IAAI,EAAEjB,MAAM,EAAE,EAAE;MACrDmB,IAAI,IAAIV,cAAc,CAACX,GAAG,EAAEqB,IAAI,CAAC;IACnC;EACF;EAEA,OAAOrB,GAAG,CAACsB,SAAS,CAACF,IAAI,EAAEC,IAAI,CAAC;AAClC;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAASC,SAASA,CAACtB,GAAG,EAAEgB,KAAK,EAAEO,GAAG,EAAE;EAClCP,KAAK,GAAGA,KAAK,IAAI,CAAC;EAClBO,GAAG,GAAGA,GAAG,KAAKN,SAAS,GAAGC,QAAQ,GAAGK,GAAG,IAAI,CAAC;EAE7C,IAAIP,KAAK,GAAG,CAAC,EAAE;IACbA,KAAK,GAAG,CAAC;EACX;EACA,IAAIO,GAAG,GAAG,CAAC,EAAE;IACXA,GAAG,GAAG,CAAC;EACT;EAEA,IAAIrB,MAAM,GAAGsB,IAAI,CAACC,GAAG,CAACF,GAAG,GAAGP,KAAK,CAAC;EAClCA,KAAK,GAAGA,KAAK,GAAGO,GAAG,GAAGP,KAAK,GAAGO,GAAG;EACjC,OAAOR,MAAM,CAACf,GAAG,EAAEgB,KAAK,EAAEd,MAAM,CAAC;AACnC;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,SAASwB,aAAaA,CAAC1B,GAAG,EAAE;EAC1B,IAAI2B,UAAU,GAAG,EAAE;EACnB,KAAK,IAAIf,GAAG,GAAG,CAAC,EAAEA,GAAG,GAAGZ,GAAG,CAACE,MAAM,EAAEU,GAAG,IAAID,cAAc,CAACX,GAAG,EAAEY,GAAG,CAAC,EAAE;IACnEe,UAAU,CAACC,IAAI,CAAC5B,GAAG,CAAC6B,WAAW,CAACjB,GAAG,CAAC,CAAC;EACvC;EACA,OAAOe,UAAU;AACnB;AAEA,IAAIG,YAAY,GAAG;EACjBJ,aAAa,EAAEA,aAAa;EAC5Bf,cAAc,EAAEA,cAAc;EAC9BF,gBAAgB,EAAEA,gBAAgB;EAClCZ,0BAA0B,EAAEA,0BAA0B;EACtDE,eAAe,EAAEA,eAAe;EAChCc,MAAM,EAAEA,MAAM;EACdS,SAAS,EAAEA,SAAS;EACpBP,MAAM,EAAEA;AACV,CAAC;AAEDgB,MAAM,CAACC,OAAO,GAAGF,YAAY"},"metadata":{},"sourceType":"script","externalDependencies":[]}