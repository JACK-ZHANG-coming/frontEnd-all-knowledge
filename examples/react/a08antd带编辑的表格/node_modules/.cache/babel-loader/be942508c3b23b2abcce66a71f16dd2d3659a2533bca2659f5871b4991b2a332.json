{"ast":null,"code":"/**\n * Copyright (c) 2013-present, Facebook, Inc.\n * All rights reserved.\n *\n * This source code is licensed under the BSD-style license found in the\n * LICENSE file in the root directory of this source tree. An additional grant\n * of patent rights can be found in the PATENTS file in the same directory.\n *\n * @providesModule insertFragmentIntoContentState\n * @format\n * \n */\n\n'use strict';\n\nvar BlockMapBuilder = require('./BlockMapBuilder');\nvar ContentBlockNode = require('./ContentBlockNode');\nvar Immutable = require('immutable');\nvar insertIntoList = require('./insertIntoList');\nvar invariant = require('fbjs/lib/invariant');\nvar randomizeBlockMapKeys = require('./randomizeBlockMapKeys');\nvar List = Immutable.List;\nvar updateExistingBlock = function updateExistingBlock(contentState, selectionState, blockMap, fragmentBlock, targetKey, targetOffset) {\n  var targetBlock = blockMap.get(targetKey);\n  var text = targetBlock.getText();\n  var chars = targetBlock.getCharacterList();\n  var finalKey = targetKey;\n  var finalOffset = targetOffset + fragmentBlock.getText().length;\n  var newBlock = targetBlock.merge({\n    text: text.slice(0, targetOffset) + fragmentBlock.getText() + text.slice(targetOffset),\n    characterList: insertIntoList(chars, fragmentBlock.getCharacterList(), targetOffset),\n    data: fragmentBlock.getData()\n  });\n  return contentState.merge({\n    blockMap: blockMap.set(targetKey, newBlock),\n    selectionBefore: selectionState,\n    selectionAfter: selectionState.merge({\n      anchorKey: finalKey,\n      anchorOffset: finalOffset,\n      focusKey: finalKey,\n      focusOffset: finalOffset,\n      isBackward: false\n    })\n  });\n};\n\n/**\n * Appends text/characterList from the fragment first block to\n * target block.\n */\nvar updateHead = function updateHead(block, targetOffset, fragment) {\n  var text = block.getText();\n  var chars = block.getCharacterList();\n\n  // Modify head portion of block.\n  var headText = text.slice(0, targetOffset);\n  var headCharacters = chars.slice(0, targetOffset);\n  var appendToHead = fragment.first();\n  return block.merge({\n    text: headText + appendToHead.getText(),\n    characterList: headCharacters.concat(appendToHead.getCharacterList()),\n    type: headText ? block.getType() : appendToHead.getType(),\n    data: appendToHead.getData()\n  });\n};\n\n/**\n * Appends offset text/characterList from the target block to the last\n * fragment block.\n */\nvar updateTail = function updateTail(block, targetOffset, fragment) {\n  // Modify tail portion of block.\n  var text = block.getText();\n  var chars = block.getCharacterList();\n\n  // Modify head portion of block.\n  var blockSize = text.length;\n  var tailText = text.slice(targetOffset, blockSize);\n  var tailCharacters = chars.slice(targetOffset, blockSize);\n  var prependToTail = fragment.last();\n  return prependToTail.merge({\n    text: prependToTail.getText() + tailText,\n    characterList: prependToTail.getCharacterList().concat(tailCharacters),\n    data: prependToTail.getData()\n  });\n};\nvar getRootBlocks = function getRootBlocks(block, blockMap) {\n  var headKey = block.getKey();\n  var rootBlock = block;\n  var rootBlocks = [];\n\n  // sometimes the fragment head block will not be part of the blockMap itself this can happen when\n  // the fragment head is used to update the target block, however when this does not happen we need\n  // to make sure that we include it on the rootBlocks since the first block of a fragment is always a\n  // fragment root block\n  if (blockMap.get(headKey)) {\n    rootBlocks.push(headKey);\n  }\n  while (rootBlock && rootBlock.getNextSiblingKey()) {\n    var lastSiblingKey = rootBlock.getNextSiblingKey();\n    if (!lastSiblingKey) {\n      break;\n    }\n    rootBlocks.push(lastSiblingKey);\n    rootBlock = blockMap.get(lastSiblingKey);\n  }\n  return rootBlocks;\n};\nvar updateBlockMapLinks = function updateBlockMapLinks(blockMap, originalBlockMap, targetBlock, fragmentHeadBlock) {\n  return blockMap.withMutations(function (blockMapState) {\n    var targetKey = targetBlock.getKey();\n    var headKey = fragmentHeadBlock.getKey();\n    var targetNextKey = targetBlock.getNextSiblingKey();\n    var targetParentKey = targetBlock.getParentKey();\n    var fragmentRootBlocks = getRootBlocks(fragmentHeadBlock, blockMap);\n    var lastRootFragmentBlockKey = fragmentRootBlocks[fragmentRootBlocks.length - 1];\n    if (blockMapState.get(headKey)) {\n      // update the fragment head when it is part of the blockMap otherwise\n      blockMapState.setIn([targetKey, 'nextSibling'], headKey);\n      blockMapState.setIn([headKey, 'prevSibling'], targetKey);\n    } else {\n      // update the target block that had the fragment head contents merged into it\n      blockMapState.setIn([targetKey, 'nextSibling'], fragmentHeadBlock.getNextSiblingKey());\n      blockMapState.setIn([fragmentHeadBlock.getNextSiblingKey(), 'prevSibling'], targetKey);\n    }\n\n    // update the last root block fragment\n    blockMapState.setIn([lastRootFragmentBlockKey, 'nextSibling'], targetNextKey);\n\n    // update the original target next block\n    if (targetNextKey) {\n      blockMapState.setIn([targetNextKey, 'prevSibling'], lastRootFragmentBlockKey);\n    }\n\n    // update fragment parent links\n    fragmentRootBlocks.forEach(function (blockKey) {\n      return blockMapState.setIn([blockKey, 'parent'], targetParentKey);\n    });\n\n    // update targetBlock parent child links\n    if (targetParentKey) {\n      var targetParent = blockMap.get(targetParentKey);\n      var originalTargetParentChildKeys = targetParent.getChildKeys();\n      var targetBlockIndex = originalTargetParentChildKeys.indexOf(targetKey);\n      var insertionIndex = targetBlockIndex + 1;\n      var newChildrenKeysArray = originalTargetParentChildKeys.toArray();\n\n      // insert fragment children\n      newChildrenKeysArray.splice.apply(newChildrenKeysArray, [insertionIndex, 0].concat(fragmentRootBlocks));\n      blockMapState.setIn([targetParentKey, 'children'], List(newChildrenKeysArray));\n    }\n  });\n};\nvar insertFragment = function insertFragment(contentState, selectionState, blockMap, fragment, targetKey, targetOffset) {\n  var isTreeBasedBlockMap = blockMap.first() instanceof ContentBlockNode;\n  var newBlockArr = [];\n  var fragmentSize = fragment.size;\n  var target = blockMap.get(targetKey);\n  var head = fragment.first();\n  var tail = fragment.last();\n  var finalOffset = tail.getLength();\n  var finalKey = tail.getKey();\n  var shouldNotUpdateFromFragmentBlock = isTreeBasedBlockMap && (!target.getChildKeys().isEmpty() || !head.getChildKeys().isEmpty());\n  blockMap.forEach(function (block, blockKey) {\n    if (blockKey !== targetKey) {\n      newBlockArr.push(block);\n      return;\n    }\n    if (shouldNotUpdateFromFragmentBlock) {\n      newBlockArr.push(block);\n    } else {\n      newBlockArr.push(updateHead(block, targetOffset, fragment));\n    }\n\n    // Insert fragment blocks after the head and before the tail.\n    fragment\n    // when we are updating the target block with the head fragment block we skip the first fragment\n    // head since its contents have already been merged with the target block otherwise we include\n    // the whole fragment\n    .slice(shouldNotUpdateFromFragmentBlock ? 0 : 1, fragmentSize - 1).forEach(function (fragmentBlock) {\n      return newBlockArr.push(fragmentBlock);\n    });\n\n    // update tail\n    newBlockArr.push(updateTail(block, targetOffset, fragment));\n  });\n  var updatedBlockMap = BlockMapBuilder.createFromArray(newBlockArr);\n  if (isTreeBasedBlockMap) {\n    updatedBlockMap = updateBlockMapLinks(updatedBlockMap, blockMap, target, head);\n  }\n  return contentState.merge({\n    blockMap: updatedBlockMap,\n    selectionBefore: selectionState,\n    selectionAfter: selectionState.merge({\n      anchorKey: finalKey,\n      anchorOffset: finalOffset,\n      focusKey: finalKey,\n      focusOffset: finalOffset,\n      isBackward: false\n    })\n  });\n};\nvar insertFragmentIntoContentState = function insertFragmentIntoContentState(contentState, selectionState, fragmentBlockMap) {\n  !selectionState.isCollapsed() ? process.env.NODE_ENV !== 'production' ? invariant(false, '`insertFragment` should only be called with a collapsed selection state.') : invariant(false) : void 0;\n  var blockMap = contentState.getBlockMap();\n  var fragment = randomizeBlockMapKeys(fragmentBlockMap);\n  var targetKey = selectionState.getStartKey();\n  var targetOffset = selectionState.getStartOffset();\n  var targetBlock = blockMap.get(targetKey);\n  if (targetBlock instanceof ContentBlockNode) {\n    !targetBlock.getChildKeys().isEmpty() ? process.env.NODE_ENV !== 'production' ? invariant(false, '`insertFragment` should not be called when a container node is selected.') : invariant(false) : void 0;\n  }\n\n  // When we insert a fragment with a single block we simply update the target block\n  // with the contents of the inserted fragment block\n  if (fragment.size === 1) {\n    return updateExistingBlock(contentState, selectionState, blockMap, fragment.first(), targetKey, targetOffset);\n  }\n  return insertFragment(contentState, selectionState, blockMap, fragment, targetKey, targetOffset);\n};\nmodule.exports = insertFragmentIntoContentState;","map":{"version":3,"names":["BlockMapBuilder","require","ContentBlockNode","Immutable","insertIntoList","invariant","randomizeBlockMapKeys","List","updateExistingBlock","contentState","selectionState","blockMap","fragmentBlock","targetKey","targetOffset","targetBlock","get","text","getText","chars","getCharacterList","finalKey","finalOffset","length","newBlock","merge","slice","characterList","data","getData","set","selectionBefore","selectionAfter","anchorKey","anchorOffset","focusKey","focusOffset","isBackward","updateHead","block","fragment","headText","headCharacters","appendToHead","first","concat","type","getType","updateTail","blockSize","tailText","tailCharacters","prependToTail","last","getRootBlocks","headKey","getKey","rootBlock","rootBlocks","push","getNextSiblingKey","lastSiblingKey","updateBlockMapLinks","originalBlockMap","fragmentHeadBlock","withMutations","blockMapState","targetNextKey","targetParentKey","getParentKey","fragmentRootBlocks","lastRootFragmentBlockKey","setIn","forEach","blockKey","targetParent","originalTargetParentChildKeys","getChildKeys","targetBlockIndex","indexOf","insertionIndex","newChildrenKeysArray","toArray","splice","apply","insertFragment","isTreeBasedBlockMap","newBlockArr","fragmentSize","size","target","head","tail","getLength","shouldNotUpdateFromFragmentBlock","isEmpty","updatedBlockMap","createFromArray","insertFragmentIntoContentState","fragmentBlockMap","isCollapsed","process","env","NODE_ENV","getBlockMap","getStartKey","getStartOffset","module","exports"],"sources":["/Users/zhangqiang/Documents/GitHub/frontEnd-all-knowledge/examples/react/a08antd带编辑的表格/node_modules/rc-editor-mention/node_modules/draft-js/lib/insertFragmentIntoContentState.js"],"sourcesContent":["/**\n * Copyright (c) 2013-present, Facebook, Inc.\n * All rights reserved.\n *\n * This source code is licensed under the BSD-style license found in the\n * LICENSE file in the root directory of this source tree. An additional grant\n * of patent rights can be found in the PATENTS file in the same directory.\n *\n * @providesModule insertFragmentIntoContentState\n * @format\n * \n */\n\n'use strict';\n\nvar BlockMapBuilder = require('./BlockMapBuilder');\nvar ContentBlockNode = require('./ContentBlockNode');\nvar Immutable = require('immutable');\n\nvar insertIntoList = require('./insertIntoList');\nvar invariant = require('fbjs/lib/invariant');\nvar randomizeBlockMapKeys = require('./randomizeBlockMapKeys');\n\nvar List = Immutable.List;\n\n\nvar updateExistingBlock = function updateExistingBlock(contentState, selectionState, blockMap, fragmentBlock, targetKey, targetOffset) {\n  var targetBlock = blockMap.get(targetKey);\n  var text = targetBlock.getText();\n  var chars = targetBlock.getCharacterList();\n  var finalKey = targetKey;\n  var finalOffset = targetOffset + fragmentBlock.getText().length;\n\n  var newBlock = targetBlock.merge({\n    text: text.slice(0, targetOffset) + fragmentBlock.getText() + text.slice(targetOffset),\n    characterList: insertIntoList(chars, fragmentBlock.getCharacterList(), targetOffset),\n    data: fragmentBlock.getData()\n  });\n\n  return contentState.merge({\n    blockMap: blockMap.set(targetKey, newBlock),\n    selectionBefore: selectionState,\n    selectionAfter: selectionState.merge({\n      anchorKey: finalKey,\n      anchorOffset: finalOffset,\n      focusKey: finalKey,\n      focusOffset: finalOffset,\n      isBackward: false\n    })\n  });\n};\n\n/**\n * Appends text/characterList from the fragment first block to\n * target block.\n */\nvar updateHead = function updateHead(block, targetOffset, fragment) {\n  var text = block.getText();\n  var chars = block.getCharacterList();\n\n  // Modify head portion of block.\n  var headText = text.slice(0, targetOffset);\n  var headCharacters = chars.slice(0, targetOffset);\n  var appendToHead = fragment.first();\n\n  return block.merge({\n    text: headText + appendToHead.getText(),\n    characterList: headCharacters.concat(appendToHead.getCharacterList()),\n    type: headText ? block.getType() : appendToHead.getType(),\n    data: appendToHead.getData()\n  });\n};\n\n/**\n * Appends offset text/characterList from the target block to the last\n * fragment block.\n */\nvar updateTail = function updateTail(block, targetOffset, fragment) {\n  // Modify tail portion of block.\n  var text = block.getText();\n  var chars = block.getCharacterList();\n\n  // Modify head portion of block.\n  var blockSize = text.length;\n  var tailText = text.slice(targetOffset, blockSize);\n  var tailCharacters = chars.slice(targetOffset, blockSize);\n  var prependToTail = fragment.last();\n\n  return prependToTail.merge({\n    text: prependToTail.getText() + tailText,\n    characterList: prependToTail.getCharacterList().concat(tailCharacters),\n    data: prependToTail.getData()\n  });\n};\n\nvar getRootBlocks = function getRootBlocks(block, blockMap) {\n  var headKey = block.getKey();\n  var rootBlock = block;\n  var rootBlocks = [];\n\n  // sometimes the fragment head block will not be part of the blockMap itself this can happen when\n  // the fragment head is used to update the target block, however when this does not happen we need\n  // to make sure that we include it on the rootBlocks since the first block of a fragment is always a\n  // fragment root block\n  if (blockMap.get(headKey)) {\n    rootBlocks.push(headKey);\n  }\n\n  while (rootBlock && rootBlock.getNextSiblingKey()) {\n    var lastSiblingKey = rootBlock.getNextSiblingKey();\n\n    if (!lastSiblingKey) {\n      break;\n    }\n\n    rootBlocks.push(lastSiblingKey);\n    rootBlock = blockMap.get(lastSiblingKey);\n  }\n\n  return rootBlocks;\n};\n\nvar updateBlockMapLinks = function updateBlockMapLinks(blockMap, originalBlockMap, targetBlock, fragmentHeadBlock) {\n  return blockMap.withMutations(function (blockMapState) {\n    var targetKey = targetBlock.getKey();\n    var headKey = fragmentHeadBlock.getKey();\n    var targetNextKey = targetBlock.getNextSiblingKey();\n    var targetParentKey = targetBlock.getParentKey();\n    var fragmentRootBlocks = getRootBlocks(fragmentHeadBlock, blockMap);\n    var lastRootFragmentBlockKey = fragmentRootBlocks[fragmentRootBlocks.length - 1];\n\n    if (blockMapState.get(headKey)) {\n      // update the fragment head when it is part of the blockMap otherwise\n      blockMapState.setIn([targetKey, 'nextSibling'], headKey);\n      blockMapState.setIn([headKey, 'prevSibling'], targetKey);\n    } else {\n      // update the target block that had the fragment head contents merged into it\n      blockMapState.setIn([targetKey, 'nextSibling'], fragmentHeadBlock.getNextSiblingKey());\n      blockMapState.setIn([fragmentHeadBlock.getNextSiblingKey(), 'prevSibling'], targetKey);\n    }\n\n    // update the last root block fragment\n    blockMapState.setIn([lastRootFragmentBlockKey, 'nextSibling'], targetNextKey);\n\n    // update the original target next block\n    if (targetNextKey) {\n      blockMapState.setIn([targetNextKey, 'prevSibling'], lastRootFragmentBlockKey);\n    }\n\n    // update fragment parent links\n    fragmentRootBlocks.forEach(function (blockKey) {\n      return blockMapState.setIn([blockKey, 'parent'], targetParentKey);\n    });\n\n    // update targetBlock parent child links\n    if (targetParentKey) {\n      var targetParent = blockMap.get(targetParentKey);\n      var originalTargetParentChildKeys = targetParent.getChildKeys();\n\n      var targetBlockIndex = originalTargetParentChildKeys.indexOf(targetKey);\n      var insertionIndex = targetBlockIndex + 1;\n\n      var newChildrenKeysArray = originalTargetParentChildKeys.toArray();\n\n      // insert fragment children\n      newChildrenKeysArray.splice.apply(newChildrenKeysArray, [insertionIndex, 0].concat(fragmentRootBlocks));\n\n      blockMapState.setIn([targetParentKey, 'children'], List(newChildrenKeysArray));\n    }\n  });\n};\n\nvar insertFragment = function insertFragment(contentState, selectionState, blockMap, fragment, targetKey, targetOffset) {\n  var isTreeBasedBlockMap = blockMap.first() instanceof ContentBlockNode;\n  var newBlockArr = [];\n  var fragmentSize = fragment.size;\n  var target = blockMap.get(targetKey);\n  var head = fragment.first();\n  var tail = fragment.last();\n  var finalOffset = tail.getLength();\n  var finalKey = tail.getKey();\n  var shouldNotUpdateFromFragmentBlock = isTreeBasedBlockMap && (!target.getChildKeys().isEmpty() || !head.getChildKeys().isEmpty());\n\n  blockMap.forEach(function (block, blockKey) {\n    if (blockKey !== targetKey) {\n      newBlockArr.push(block);\n      return;\n    }\n\n    if (shouldNotUpdateFromFragmentBlock) {\n      newBlockArr.push(block);\n    } else {\n      newBlockArr.push(updateHead(block, targetOffset, fragment));\n    }\n\n    // Insert fragment blocks after the head and before the tail.\n    fragment\n    // when we are updating the target block with the head fragment block we skip the first fragment\n    // head since its contents have already been merged with the target block otherwise we include\n    // the whole fragment\n    .slice(shouldNotUpdateFromFragmentBlock ? 0 : 1, fragmentSize - 1).forEach(function (fragmentBlock) {\n      return newBlockArr.push(fragmentBlock);\n    });\n\n    // update tail\n    newBlockArr.push(updateTail(block, targetOffset, fragment));\n  });\n\n  var updatedBlockMap = BlockMapBuilder.createFromArray(newBlockArr);\n\n  if (isTreeBasedBlockMap) {\n    updatedBlockMap = updateBlockMapLinks(updatedBlockMap, blockMap, target, head);\n  }\n\n  return contentState.merge({\n    blockMap: updatedBlockMap,\n    selectionBefore: selectionState,\n    selectionAfter: selectionState.merge({\n      anchorKey: finalKey,\n      anchorOffset: finalOffset,\n      focusKey: finalKey,\n      focusOffset: finalOffset,\n      isBackward: false\n    })\n  });\n};\n\nvar insertFragmentIntoContentState = function insertFragmentIntoContentState(contentState, selectionState, fragmentBlockMap) {\n  !selectionState.isCollapsed() ? process.env.NODE_ENV !== 'production' ? invariant(false, '`insertFragment` should only be called with a collapsed selection state.') : invariant(false) : void 0;\n\n  var blockMap = contentState.getBlockMap();\n  var fragment = randomizeBlockMapKeys(fragmentBlockMap);\n  var targetKey = selectionState.getStartKey();\n  var targetOffset = selectionState.getStartOffset();\n\n  var targetBlock = blockMap.get(targetKey);\n\n  if (targetBlock instanceof ContentBlockNode) {\n    !targetBlock.getChildKeys().isEmpty() ? process.env.NODE_ENV !== 'production' ? invariant(false, '`insertFragment` should not be called when a container node is selected.') : invariant(false) : void 0;\n  }\n\n  // When we insert a fragment with a single block we simply update the target block\n  // with the contents of the inserted fragment block\n  if (fragment.size === 1) {\n    return updateExistingBlock(contentState, selectionState, blockMap, fragment.first(), targetKey, targetOffset);\n  }\n\n  return insertFragment(contentState, selectionState, blockMap, fragment, targetKey, targetOffset);\n};\n\nmodule.exports = insertFragmentIntoContentState;"],"mappings":"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"},"metadata":{},"sourceType":"script","externalDependencies":[]}