{"ast":null,"code":"import { isFirefox, isSafari } from './BrowserDetector.js';\nimport { MonotonicInterpolant } from './MonotonicInterpolant.js';\nvar ELEMENT_NODE = 1;\nexport function getNodeClientOffset(node) {\n  var el = node.nodeType === ELEMENT_NODE ? node : node.parentElement;\n  if (!el) {\n    return null;\n  }\n  var _el$getBoundingClient = el.getBoundingClientRect(),\n    top = _el$getBoundingClient.top,\n    left = _el$getBoundingClient.left;\n  return {\n    x: left,\n    y: top\n  };\n}\nexport function getEventClientOffset(e) {\n  return {\n    x: e.clientX,\n    y: e.clientY\n  };\n}\nfunction isImageNode(node) {\n  var ref;\n  return node.nodeName === 'IMG' && (isFirefox() || !((ref = document.documentElement) === null || ref === void 0 ? void 0 : ref.contains(node)));\n}\nfunction getDragPreviewSize(isImage, dragPreview, sourceWidth, sourceHeight) {\n  var dragPreviewWidth = isImage ? dragPreview.width : sourceWidth;\n  var dragPreviewHeight = isImage ? dragPreview.height : sourceHeight;\n  // Work around @2x coordinate discrepancies in browsers\n  if (isSafari() && isImage) {\n    dragPreviewHeight /= window.devicePixelRatio;\n    dragPreviewWidth /= window.devicePixelRatio;\n  }\n  return {\n    dragPreviewWidth: dragPreviewWidth,\n    dragPreviewHeight: dragPreviewHeight\n  };\n}\nexport function getDragPreviewOffset(sourceNode, dragPreview, clientOffset, anchorPoint, offsetPoint) {\n  // The browsers will use the image intrinsic size under different conditions.\n  // Firefox only cares if it's an image, but WebKit also wants it to be detached.\n  var isImage = isImageNode(dragPreview);\n  var dragPreviewNode = isImage ? sourceNode : dragPreview;\n  var dragPreviewNodeOffsetFromClient = getNodeClientOffset(dragPreviewNode);\n  var offsetFromDragPreview = {\n    x: clientOffset.x - dragPreviewNodeOffsetFromClient.x,\n    y: clientOffset.y - dragPreviewNodeOffsetFromClient.y\n  };\n  var sourceWidth = sourceNode.offsetWidth,\n    sourceHeight = sourceNode.offsetHeight;\n  var anchorX = anchorPoint.anchorX,\n    anchorY = anchorPoint.anchorY;\n  var _getDragPreviewSize = getDragPreviewSize(isImage, dragPreview, sourceWidth, sourceHeight),\n    dragPreviewWidth = _getDragPreviewSize.dragPreviewWidth,\n    dragPreviewHeight = _getDragPreviewSize.dragPreviewHeight;\n  var calculateYOffset = function calculateYOffset() {\n    var interpolantY = new MonotonicInterpolant([0, 0.5, 1], [\n    // Dock to the top\n    offsetFromDragPreview.y,\n    // Align at the center\n    offsetFromDragPreview.y / sourceHeight * dragPreviewHeight,\n    // Dock to the bottom\n    offsetFromDragPreview.y + dragPreviewHeight - sourceHeight]);\n    var y = interpolantY.interpolate(anchorY);\n    // Work around Safari 8 positioning bug\n    if (isSafari() && isImage) {\n      // We'll have to wait for @3x to see if this is entirely correct\n      y += (window.devicePixelRatio - 1) * dragPreviewHeight;\n    }\n    return y;\n  };\n  var calculateXOffset = function calculateXOffset() {\n    // Interpolate coordinates depending on anchor point\n    // If you know a simpler way to do this, let me know\n    var interpolantX = new MonotonicInterpolant([0, 0.5, 1], [\n    // Dock to the left\n    offsetFromDragPreview.x,\n    // Align at the center\n    offsetFromDragPreview.x / sourceWidth * dragPreviewWidth,\n    // Dock to the right\n    offsetFromDragPreview.x + dragPreviewWidth - sourceWidth]);\n    return interpolantX.interpolate(anchorX);\n  };\n  // Force offsets if specified in the options.\n  var offsetX = offsetPoint.offsetX,\n    offsetY = offsetPoint.offsetY;\n  var isManualOffsetX = offsetX === 0 || offsetX;\n  var isManualOffsetY = offsetY === 0 || offsetY;\n  return {\n    x: isManualOffsetX ? offsetX : calculateXOffset(),\n    y: isManualOffsetY ? offsetY : calculateYOffset()\n  };\n}","map":{"version":3,"names":["isFirefox","isSafari","MonotonicInterpolant","ELEMENT_NODE","getNodeClientOffset","node","el","nodeType","parentElement","_el$getBoundingClient","getBoundingClientRect","top","left","x","y","getEventClientOffset","e","clientX","clientY","isImageNode","ref","nodeName","document","documentElement","contains","getDragPreviewSize","isImage","dragPreview","sourceWidth","sourceHeight","dragPreviewWidth","width","dragPreviewHeight","height","window","devicePixelRatio","getDragPreviewOffset","sourceNode","clientOffset","anchorPoint","offsetPoint","dragPreviewNode","dragPreviewNodeOffsetFromClient","offsetFromDragPreview","offsetWidth","offsetHeight","anchorX","anchorY","_getDragPreviewSize","calculateYOffset","interpolantY","interpolate","calculateXOffset","interpolantX","offsetX","offsetY","isManualOffsetX","isManualOffsetY"],"sources":["/Users/zhangqiang/Documents/GitHub/frontEnd-all-knowledge/examples/react/a08antd带编辑的表格/node_modules/react-dnd-html5-backend/src/OffsetUtils.ts"],"sourcesContent":["import type { XYCoord } from 'dnd-core'\n\nimport { isFirefox, isSafari } from './BrowserDetector.js'\nimport { MonotonicInterpolant } from './MonotonicInterpolant.js'\n\nconst ELEMENT_NODE = 1\n\nexport function getNodeClientOffset(node: Node): XYCoord | null {\n\tconst el = node.nodeType === ELEMENT_NODE ? node : node.parentElement\n\n\tif (!el) {\n\t\treturn null\n\t}\n\n\tconst { top, left } = (el as HTMLElement).getBoundingClientRect()\n\treturn { x: left, y: top }\n}\n\nexport function getEventClientOffset(e: MouseEvent): XYCoord {\n\treturn {\n\t\tx: e.clientX,\n\t\ty: e.clientY,\n\t}\n}\n\nfunction isImageNode(node: any) {\n\treturn (\n\t\tnode.nodeName === 'IMG' &&\n\t\t(isFirefox() || !document.documentElement?.contains(node))\n\t)\n}\n\nfunction getDragPreviewSize(\n\tisImage: boolean,\n\tdragPreview: any,\n\tsourceWidth: number,\n\tsourceHeight: number,\n) {\n\tlet dragPreviewWidth = isImage ? dragPreview.width : sourceWidth\n\tlet dragPreviewHeight = isImage ? dragPreview.height : sourceHeight\n\n\t// Work around @2x coordinate discrepancies in browsers\n\tif (isSafari() && isImage) {\n\t\tdragPreviewHeight /= window.devicePixelRatio\n\t\tdragPreviewWidth /= window.devicePixelRatio\n\t}\n\treturn { dragPreviewWidth, dragPreviewHeight }\n}\n\nexport function getDragPreviewOffset(\n\tsourceNode: HTMLElement,\n\tdragPreview: HTMLElement,\n\tclientOffset: XYCoord,\n\tanchorPoint: { anchorX: number; anchorY: number },\n\toffsetPoint: { offsetX: number; offsetY: number },\n): XYCoord {\n\t// The browsers will use the image intrinsic size under different conditions.\n\t// Firefox only cares if it's an image, but WebKit also wants it to be detached.\n\tconst isImage = isImageNode(dragPreview)\n\tconst dragPreviewNode = isImage ? sourceNode : dragPreview\n\tconst dragPreviewNodeOffsetFromClient = getNodeClientOffset(\n\t\tdragPreviewNode,\n\t) as XYCoord\n\tconst offsetFromDragPreview = {\n\t\tx: clientOffset.x - dragPreviewNodeOffsetFromClient.x,\n\t\ty: clientOffset.y - dragPreviewNodeOffsetFromClient.y,\n\t}\n\tconst { offsetWidth: sourceWidth, offsetHeight: sourceHeight } = sourceNode\n\tconst { anchorX, anchorY } = anchorPoint\n\tconst { dragPreviewWidth, dragPreviewHeight } = getDragPreviewSize(\n\t\tisImage,\n\t\tdragPreview,\n\t\tsourceWidth,\n\t\tsourceHeight,\n\t)\n\n\tconst calculateYOffset = () => {\n\t\tconst interpolantY = new MonotonicInterpolant(\n\t\t\t[0, 0.5, 1],\n\t\t\t[\n\t\t\t\t// Dock to the top\n\t\t\t\toffsetFromDragPreview.y,\n\t\t\t\t// Align at the center\n\t\t\t\t(offsetFromDragPreview.y / sourceHeight) * dragPreviewHeight,\n\t\t\t\t// Dock to the bottom\n\t\t\t\toffsetFromDragPreview.y + dragPreviewHeight - sourceHeight,\n\t\t\t],\n\t\t)\n\t\tlet y = interpolantY.interpolate(anchorY)\n\t\t// Work around Safari 8 positioning bug\n\t\tif (isSafari() && isImage) {\n\t\t\t// We'll have to wait for @3x to see if this is entirely correct\n\t\t\ty += (window.devicePixelRatio - 1) * dragPreviewHeight\n\t\t}\n\t\treturn y\n\t}\n\n\tconst calculateXOffset = () => {\n\t\t// Interpolate coordinates depending on anchor point\n\t\t// If you know a simpler way to do this, let me know\n\t\tconst interpolantX = new MonotonicInterpolant(\n\t\t\t[0, 0.5, 1],\n\t\t\t[\n\t\t\t\t// Dock to the left\n\t\t\t\toffsetFromDragPreview.x,\n\t\t\t\t// Align at the center\n\t\t\t\t(offsetFromDragPreview.x / sourceWidth) * dragPreviewWidth,\n\t\t\t\t// Dock to the right\n\t\t\t\toffsetFromDragPreview.x + dragPreviewWidth - sourceWidth,\n\t\t\t],\n\t\t)\n\t\treturn interpolantX.interpolate(anchorX)\n\t}\n\n\t// Force offsets if specified in the options.\n\tconst { offsetX, offsetY } = offsetPoint\n\tconst isManualOffsetX = offsetX === 0 || offsetX\n\tconst isManualOffsetY = offsetY === 0 || offsetY\n\treturn {\n\t\tx: isManualOffsetX ? offsetX : calculateXOffset(),\n\t\ty: isManualOffsetY ? offsetY : calculateYOffset(),\n\t}\n}\n"],"mappings":"AAEA,SAASA,SAAS,EAAEC,QAAQ,QAAQ,sBAAsB;AAC1D,SAASC,oBAAoB,QAAQ,2BAA2B;AAEhE,IAAMC,YAAY,GAAG,CAAC;AAEtB,OAAO,SAASC,mBAAmBA,CAACC,IAAU,EAAkB;EAC/D,IAAMC,EAAE,GAAGD,IAAI,CAACE,QAAQ,KAAKJ,YAAY,GAAGE,IAAI,GAAGA,IAAI,CAACG,aAAa;EAErE,IAAI,CAACF,EAAE,EAAE;IACR,OAAO,IAAI;;EAGZ,IAAAG,qBAAA,GAAsBH,EAAG,CAAiBI,qBAAqB,EAAE;IAAzDC,GAAG,GAAAF,qBAAA,CAAHE,GAAG;IAAEC,IAAI,GAAAH,qBAAA,CAAJG,IAAI;EACjB,OAAO;IAAEC,CAAC,EAAED,IAAI;IAAEE,CAAC,EAAEH;GAAK;;AAG3B,OAAO,SAASI,oBAAoBA,CAACC,CAAa,EAAW;EAC5D,OAAO;IACNH,CAAC,EAAEG,CAAC,CAACC,OAAO;IACZH,CAAC,EAAEE,CAAC,CAACE;GACL;;AAGF,SAASC,WAAWA,CAACd,IAAS,EAAE;MAGbe,GAAwB;EAF1C,OACCf,IAAI,CAACgB,QAAQ,KAAK,KAAK,KACtBrB,SAAS,EAAE,IAAI,EAAC,CAAAoB,GAAwB,GAAxBE,QAAQ,CAACC,eAAe,cAAxBH,GAAwB,WAAU,GAAlC,MAAkC,GAAlCA,GAAwB,CAAEI,QAAQ,CAACnB,IAAI,CAAC,EAAC;;AAI5D,SAASoB,kBAAkBA,CAC1BC,OAAgB,EAChBC,WAAgB,EAChBC,WAAmB,EACnBC,YAAoB,EACnB;EACD,IAAIC,gBAAgB,GAAGJ,OAAO,GAAGC,WAAW,CAACI,KAAK,GAAGH,WAAW;EAChE,IAAII,iBAAiB,GAAGN,OAAO,GAAGC,WAAW,CAACM,MAAM,GAAGJ,YAAY;EAEnE;EACA,IAAI5B,QAAQ,EAAE,IAAIyB,OAAO,EAAE;IAC1BM,iBAAiB,IAAIE,MAAM,CAACC,gBAAgB;IAC5CL,gBAAgB,IAAII,MAAM,CAACC,gBAAgB;;EAE5C,OAAO;IAAEL,gBAAgB,EAAhBA,gBAAgB;IAAEE,iBAAiB,EAAjBA;GAAmB;;AAG/C,OAAO,SAASI,oBAAoBA,CACnCC,UAAuB,EACvBV,WAAwB,EACxBW,YAAqB,EACrBC,WAAiD,EACjDC,WAAiD,EACvC;EACV;EACA;EACA,IAAMd,OAAO,GAAGP,WAAW,CAACQ,WAAW,CAAC;EACxC,IAAMc,eAAe,GAAGf,OAAO,GAAGW,UAAU,GAAGV,WAAW;EAC1D,IAAMe,+BAA+B,GAAGtC,mBAAmB,CAC1DqC,eAAe,CACf;EACD,IAAME,qBAAqB,GAAG;IAC7B9B,CAAC,EAAEyB,YAAY,CAACzB,CAAC,GAAG6B,+BAA+B,CAAC7B,CAAC;IACrDC,CAAC,EAAEwB,YAAY,CAACxB,CAAC,GAAG4B,+BAA+B,CAAC5B;GACpD;EACD,IAAqBc,WAAW,GAAiCS,UAAU,CAAnEO,WAAW;IAA6Bf,YAAY,GAAKQ,UAAU,CAAzCQ,YAAY;EAC9C,IAAQC,OAAO,GAAcP,WAAW,CAAhCO,OAAO;IAAEC,OAAO,GAAKR,WAAW,CAAvBQ,OAAO;EACxB,IAAAC,mBAAA,GAAgDvB,kBAAkB,CACjEC,OAAO,EACPC,WAAW,EACXC,WAAW,EACXC,YAAY,CACZ;IALOC,gBAAgB,GAAAkB,mBAAA,CAAhBlB,gBAAgB;IAAEE,iBAAiB,GAAAgB,mBAAA,CAAjBhB,iBAAiB;EAO3C,IAAMiB,gBAAgB,GAAG,SAAnBA,gBAAgBA,CAAA,EAAS;IAC9B,IAAMC,YAAY,GAAG,IAAIhD,oBAAoB,CAC5C,CAAC,CAAC,EAAE,GAAG,EAAE,CAAC,CAAC,EACX;IACC;IACAyC,qBAAqB,CAAC7B,CAAC;IACvB;IACC6B,qBAAqB,CAAC7B,CAAC,GAAGe,YAAY,GAAIG,iBAAiB;IAC5D;IACAW,qBAAqB,CAAC7B,CAAC,GAAGkB,iBAAiB,GAAGH,YAAY,CAC1D,CACD;IACD,IAAIf,CAAC,GAAGoC,YAAY,CAACC,WAAW,CAACJ,OAAO,CAAC;IACzC;IACA,IAAI9C,QAAQ,EAAE,IAAIyB,OAAO,EAAE;MAC1B;MACAZ,CAAC,IAAI,CAACoB,MAAM,CAACC,gBAAgB,GAAG,CAAC,IAAIH,iBAAiB;;IAEvD,OAAOlB,CAAC;GACR;EAED,IAAMsC,gBAAgB,GAAG,SAAnBA,gBAAgBA,CAAA,EAAS;IAC9B;IACA;IACA,IAAMC,YAAY,GAAG,IAAInD,oBAAoB,CAC5C,CAAC,CAAC,EAAE,GAAG,EAAE,CAAC,CAAC,EACX;IACC;IACAyC,qBAAqB,CAAC9B,CAAC;IACvB;IACC8B,qBAAqB,CAAC9B,CAAC,GAAGe,WAAW,GAAIE,gBAAgB;IAC1D;IACAa,qBAAqB,CAAC9B,CAAC,GAAGiB,gBAAgB,GAAGF,WAAW,CACxD,CACD;IACD,OAAOyB,YAAY,CAACF,WAAW,CAACL,OAAO,CAAC;GACxC;EAED;EACA,IAAQQ,OAAO,GAAcd,WAAW,CAAhCc,OAAO;IAAEC,OAAO,GAAKf,WAAW,CAAvBe,OAAO;EACxB,IAAMC,eAAe,GAAGF,OAAO,KAAK,CAAC,IAAIA,OAAO;EAChD,IAAMG,eAAe,GAAGF,OAAO,KAAK,CAAC,IAAIA,OAAO;EAChD,OAAO;IACN1C,CAAC,EAAE2C,eAAe,GAAGF,OAAO,GAAGF,gBAAgB,EAAE;IACjDtC,CAAC,EAAE2C,eAAe,GAAGF,OAAO,GAAGN,gBAAgB;GAC/C"},"metadata":{},"sourceType":"module","externalDependencies":[]}