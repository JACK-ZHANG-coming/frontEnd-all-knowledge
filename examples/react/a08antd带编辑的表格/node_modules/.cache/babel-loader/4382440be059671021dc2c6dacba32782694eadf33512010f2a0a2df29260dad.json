{"ast":null,"code":"import { invariant } from '@react-dnd/invariant';\nimport { cloneElement, isValidElement } from 'react';\nfunction throwIfCompositeComponentElement(element) {\n  // Custom components can no longer be wrapped directly in React DnD 2.0\n  // so that we don't need to depend on findDOMNode() from react-dom.\n  if (typeof element.type === 'string') {\n    return;\n  }\n  var displayName = element.type.displayName || element.type.name || 'the component';\n  throw new Error('Only native element nodes can now be passed to React DnD connectors.' + \"You can either wrap \".concat(displayName, \" into a <div>, or turn it into a \") + 'drag source or a drop target itself.');\n}\nfunction wrapHookToRecognizeElement(hook) {\n  return function () {\n    var elementOrNode = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : null;\n    var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;\n\n    // When passed a node, call the hook straight away.\n    if (!isValidElement(elementOrNode)) {\n      var node = elementOrNode;\n      hook(node, options); // return the node so it can be chained (e.g. when within callback refs\n      // <div ref={node => connectDragSource(connectDropTarget(node))}/>\n\n      return node;\n    } // If passed a ReactElement, clone it and attach this function as a ref.\n    // This helps us achieve a neat API where user doesn't even know that refs\n    // are being used under the hood.\n\n    var element = elementOrNode;\n    throwIfCompositeComponentElement(element); // When no options are passed, use the hook directly\n\n    var ref = options ? function (node) {\n      return hook(node, options);\n    } : hook;\n    return cloneWithRef(element, ref);\n  };\n}\nexport function wrapConnectorHooks(hooks) {\n  var wrappedHooks = {};\n  Object.keys(hooks).forEach(function (key) {\n    var hook = hooks[key]; // ref objects should be passed straight through without wrapping\n\n    if (key.endsWith('Ref')) {\n      wrappedHooks[key] = hooks[key];\n    } else {\n      var wrappedHook = wrapHookToRecognizeElement(hook);\n      wrappedHooks[key] = function () {\n        return wrappedHook;\n      };\n    }\n  });\n  return wrappedHooks;\n}\nfunction setRef(ref, node) {\n  if (typeof ref === 'function') {\n    ref(node);\n  } else {\n    ref.current = node;\n  }\n}\nfunction cloneWithRef(element, newRef) {\n  var previousRef = element.ref;\n  invariant(typeof previousRef !== 'string', 'Cannot connect React DnD to an element with an existing string ref. ' + 'Please convert it to use a callback ref instead, or wrap it into a <span> or <div>. ' + 'Read more: https://reactjs.org/docs/refs-and-the-dom.html#callback-refs');\n  if (!previousRef) {\n    // When there is no ref on the element, use the new ref directly\n    return cloneElement(element, {\n      ref: newRef\n    });\n  } else {\n    return cloneElement(element, {\n      ref: function ref(node) {\n        setRef(previousRef, node);\n        setRef(newRef, node);\n      }\n    });\n  }\n}","map":{"version":3,"names":["invariant","cloneElement","isValidElement","throwIfCompositeComponentElement","element","type","displayName","name","Error","concat","wrapHookToRecognizeElement","hook","elementOrNode","arguments","length","undefined","options","node","ref","cloneWithRef","wrapConnectorHooks","hooks","wrappedHooks","Object","keys","forEach","key","endsWith","wrappedHook","setRef","current","newRef","previousRef"],"sources":["/Users/zhangqiang/Documents/GitHub/frontEnd-all-knowledge/examples/react/a08antd带编辑的表格/node_modules/react-dnd/dist/esm/internals/wrapConnectorHooks.js"],"sourcesContent":["import { invariant } from '@react-dnd/invariant';\nimport { cloneElement, isValidElement } from 'react';\n\nfunction throwIfCompositeComponentElement(element) {\n  // Custom components can no longer be wrapped directly in React DnD 2.0\n  // so that we don't need to depend on findDOMNode() from react-dom.\n  if (typeof element.type === 'string') {\n    return;\n  }\n\n  var displayName = element.type.displayName || element.type.name || 'the component';\n  throw new Error('Only native element nodes can now be passed to React DnD connectors.' + \"You can either wrap \".concat(displayName, \" into a <div>, or turn it into a \") + 'drag source or a drop target itself.');\n}\n\nfunction wrapHookToRecognizeElement(hook) {\n  return function () {\n    var elementOrNode = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : null;\n    var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;\n\n    // When passed a node, call the hook straight away.\n    if (!isValidElement(elementOrNode)) {\n      var node = elementOrNode;\n      hook(node, options); // return the node so it can be chained (e.g. when within callback refs\n      // <div ref={node => connectDragSource(connectDropTarget(node))}/>\n\n      return node;\n    } // If passed a ReactElement, clone it and attach this function as a ref.\n    // This helps us achieve a neat API where user doesn't even know that refs\n    // are being used under the hood.\n\n\n    var element = elementOrNode;\n    throwIfCompositeComponentElement(element); // When no options are passed, use the hook directly\n\n    var ref = options ? function (node) {\n      return hook(node, options);\n    } : hook;\n    return cloneWithRef(element, ref);\n  };\n}\n\nexport function wrapConnectorHooks(hooks) {\n  var wrappedHooks = {};\n  Object.keys(hooks).forEach(function (key) {\n    var hook = hooks[key]; // ref objects should be passed straight through without wrapping\n\n    if (key.endsWith('Ref')) {\n      wrappedHooks[key] = hooks[key];\n    } else {\n      var wrappedHook = wrapHookToRecognizeElement(hook);\n\n      wrappedHooks[key] = function () {\n        return wrappedHook;\n      };\n    }\n  });\n  return wrappedHooks;\n}\n\nfunction setRef(ref, node) {\n  if (typeof ref === 'function') {\n    ref(node);\n  } else {\n    ref.current = node;\n  }\n}\n\nfunction cloneWithRef(element, newRef) {\n  var previousRef = element.ref;\n  invariant(typeof previousRef !== 'string', 'Cannot connect React DnD to an element with an existing string ref. ' + 'Please convert it to use a callback ref instead, or wrap it into a <span> or <div>. ' + 'Read more: https://reactjs.org/docs/refs-and-the-dom.html#callback-refs');\n\n  if (!previousRef) {\n    // When there is no ref on the element, use the new ref directly\n    return cloneElement(element, {\n      ref: newRef\n    });\n  } else {\n    return cloneElement(element, {\n      ref: function ref(node) {\n        setRef(previousRef, node);\n        setRef(newRef, node);\n      }\n    });\n  }\n}"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}